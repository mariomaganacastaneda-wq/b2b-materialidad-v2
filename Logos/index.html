<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>King of the Court - Padel Tournament Engine v3.5 (MinDelta + UX)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700&family=DM+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#05080f;color:#eceff1;font-family:'DM Sans',system-ui;min-height:100vh}
input[type='date'],input[type='time'],select{color-scheme:dark}
button{transition:all .15s;cursor:pointer}button:hover{filter:brightness(1.15)}
::-webkit-scrollbar{width:5px;height:5px}
::-webkit-scrollbar-track{background:#0a1022}
::-webkit-scrollbar-thumb{background:#1a2a50;border-radius:3px}
@keyframes timerPulse{from{opacity:1;transform:scale(1)}to{opacity:0.7;transform:scale(1.01)}}
</style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.1/dist/umd/supabase.min.js"></script>
<script>
// ============================================================
// SUPABASE CLIENT
// ============================================================
var SUPABASE_URL = "https://hvrniyvupdridlaoqmmk.supabase.co";
var SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh2cm5peXZ1cGRyaWRsYW9xbW1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMyNjE3NTQsImV4cCI6MjA3ODgzNzc1NH0.fbWh4REPZhcBCl7lPlkQkYUYjtsgqbEq4KqAQFg1Rds";
var supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
if (!supabase.from) {
  // Newer versions: createClient might be nested
  var _sb = window.supabase;
  if (_sb.createClient) supabase = _sb.createClient(SUPABASE_URL, SUPABASE_ANON);
}
console.log("Supabase ready:", !!supabase, !!supabase.from);

// --- Supabase helpers ---
var SB = {
  loadPlayers: async function() {
    var res = await supabase.from("padel_players").select("*").order("ranking");
    if (res.error) { console.error("SB loadPlayers:", res.error); return null; }
    return res.data.map(function(r) {
      return { id: r.id, name: r.name, nickname: r.nickname, phone: r.phone || "", ranking: r.ranking, active: r.active, avatarUrl: r.avatar_url || null, stats: { played: r.stats_played, wins: r.stats_wins, winRate: Number(r.stats_win_rate), diff: Number(r.stats_diff), rating: Number(r.stats_rating) } };
    });
  },
  loadSessions: async function() {
    var res = await supabase.from("padel_sessions").select("*").order("created_at", { ascending: false });
    if (res.error) { console.error("SB loadSessions:", res.error); return []; }
    return res.data.map(function(r) {
      var result = r.result_json || {};
      // Players: prefer explicit players array in result_json
      var players = result.players || [];
      // Fallback: extract players from p1Matches if players array is empty/missing
      if ((!players || players.length === 0) && result.p1Matches && result.p1Matches.rounds) {
        var seen = {};
        var extracted = [];
        result.p1Matches.rounds.forEach(function(round) {
          var allInRound = (round.playing || []).concat(round.resting || []);
          allInRound.forEach(function(p) {
            if (p && p.id && !seen[p.id]) {
              seen[p.id] = true;
              extracted.push(p);
            }
          });
        });
        if (extracted.length > 0) {
          players = extracted.sort(function(a, b) { return (a.ranking || 99) - (b.ranking || 99); });
          console.log("SB loadSessions: recovered " + players.length + " players from p1Matches for session " + r.id);
        }
      }
      return { id: r.id, date: r.session_date, time: r.session_time, totalTime: r.total_time, numCourts: r.num_courts, players: players, result: result, scores: r.scores_json || {}, rankingUpdated: r.ranking_updated };
    });
  },
  saveSession: async function(session) {
    var cfg = session.result.cfg || {};
    var row = {
      id: session.id,
      session_date: session.date,
      session_time: session.time,
      total_time: session.totalTime,
      num_courts: session.numCourts,
      cfg_duration: cfg.duration || null,
      cfg_duration_sec: cfg.durationSec || null,
      cfg_rounds: cfg.rounds || null,
      cfg_remainder: cfg.remainder || null,
      cfg_used_time: cfg.usedTime || null,
      cfg_dead_time: cfg.deadTime || null,
      cfg_games_floor: cfg.gamesFloor || null,
      cfg_games_ceil: cfg.gamesCeil || null,
      cfg_activity_pct: cfg.activityPct || null,
      cfg_eq: cfg.eq || null,
      p1_rounds: session.result.p1Rounds || null,
      p2_rounds: session.result.p2Rounds || null,
      phase2_generated: session.result.phase2Generated || false,
      ranking_updated: session.rankingUpdated || false,
      result_json: Object.assign({}, session.result, { players: session.players }),
      scores_json: session.scores || {}
    };
    var res = await supabase.from("padel_sessions").upsert(row);
    if (res.error) console.error("SB saveSession:", res.error);
    // Save session players
    if (session.players && session.players.length > 0) {
      var spRows = session.players.filter(function(p) { return !p.isGuest; }).map(function(p) {
        return { session_id: session.id, player_id: p.id, ranking_at_session: p.ranking };
      });
      var res2 = await supabase.from("padel_session_players").upsert(spRows, { onConflict: "session_id,player_id" });
      if (res2.error) console.error("SB saveSessionPlayers:", res2.error);
    }
  },
  updateScores: async function(sessionId, scores) {
    var res = await supabase.from("padel_sessions").update({ scores_json: scores, updated_at: new Date().toISOString() }).eq("id", sessionId);
    if (res.error) console.error("SB updateScores:", res.error);
  },
  updateSessionResult: async function(sessionId, result, extra, players) {
    var resultWithPlayers = players ? Object.assign({}, result, { players: players }) : result;
    var upd = Object.assign({ result_json: resultWithPlayers, updated_at: new Date().toISOString() }, extra || {});
    var res = await supabase.from("padel_sessions").update(upd).eq("id", sessionId);
    if (res.error) console.error("SB updateSessionResult:", res.error);
  },
  savePlayers: async function(players) {
    var rows = players.map(function(p) {
      var s = p.stats || {};
      return { id: p.id, name: p.name, nickname: p.nickname, phone: p.phone, ranking: p.ranking, active: p.active, avatar_url: p.avatarUrl || null, stats_played: s.played || 0, stats_wins: s.wins || 0, stats_win_rate: s.winRate || 0, stats_diff: s.diff || 0, stats_rating: s.rating || 0, updated_at: new Date().toISOString() };
    });
    var res = await supabase.from("padel_players").upsert(rows);
    if (res.error) console.error("SB savePlayers:", res.error);
  },
  deleteSession: async function(sessionId) {
    // Delete session players first, then session
    await supabase.from("padel_session_players").delete().eq("session_id", sessionId);
    var res = await supabase.from("padel_sessions").delete().eq("id", sessionId);
    if (res.error) console.error("SB deleteSession:", res.error);
  },
  // ============================================================
  // REALTIME SUBSCRIPTIONS
  // ============================================================
  _realtimeChannel: null,
  _realtimeStatus: "disconnected",
  _statusCallbacks: [],
  onStatusChange: function(cb) { SB._statusCallbacks.push(cb); },
  _notifyStatus: function(status) {
    SB._realtimeStatus = status;
    SB._statusCallbacks.forEach(function(cb) { cb(status); });
  },
  subscribeRealtime: function(onSessionChange, onPlayerChange) {
    if (SB._realtimeChannel) {
      supabase.removeChannel(SB._realtimeChannel);
    }
    var channel = supabase.channel("padel-realtime", { config: { broadcast: { self: false } } });
    channel
      .on("postgres_changes", { event: "*", schema: "public", table: "padel_sessions" }, function(payload) {
        console.log("RT padel_sessions:", payload.eventType, payload.new ? payload.new.id : "");
        if (onSessionChange) onSessionChange(payload);
      })
      .on("postgres_changes", { event: "*", schema: "public", table: "padel_players" }, function(payload) {
        console.log("RT padel_players:", payload.eventType, payload.new ? payload.new.id : "");
        if (onPlayerChange) onPlayerChange(payload);
      })
      .subscribe(function(status) {
        console.log("Realtime status:", status);
        SB._notifyStatus(status === "SUBSCRIBED" ? "connected" : status === "CHANNEL_ERROR" ? "error" : "connecting");
      });
    SB._realtimeChannel = channel;
    SB._notifyStatus("connecting");
    return channel;
  },
  unsubscribeRealtime: function() {
    if (SB._realtimeChannel) {
      supabase.removeChannel(SB._realtimeChannel);
      SB._realtimeChannel = null;
      SB._notifyStatus("disconnected");
    }
  }
};
</script>
<script>
// ============================================================
// AVATAR CACHE (populated from Supabase on load)
// ============================================================
var AVATARS = {
  "Alan": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCYeIWkiEotYggPzkIDj0ol8UW8EDzSQxBEGSdgrOi0tFiMcepxIGzv/wBvPrzXGeJZZ47mKz8wledwU8NzivMjg43s0ei8U7aHQXfxJuXZlsrC3jXOAzxh2P4dKLT4h6hDIDd2tnPGxz8sPlnHt/8AXrT8IaPZeXFuto2LL8xZcnP4120nhrSri0ZJbKBlYYIMYFXyUV7qgK1V+85HPxeKrS4sxdRQxshHTYMj1FY03jy187y47SGTJwDsA/Ss+90ptC1m806Dc9uQJosnJAPGKXSYrM6c7XFugmweWj5zS+q029CZYiokdPdT2lqR5lhbYJwD5Y5rivEHlah4otilvFHGse0KowGPXP5nH4V0HiZ2jW3XnlmNcteuy3NtOBzu2k98VcaMac7xB1XUh7x0WjXOqwTPHAdrxZO1oQVbHbdnNdlP4gvV0izuYbdd9wdvKFwpz3ArmT4ntbTRESV0+1SJlVP3iuecfrWvofiWxXTLeG4ha3LAti4GA3Pr0zT13sa2VrXI7mdFvFvLuGJpJoNv3CMgMex6VUudXs41OLWH/vmmeKr1ZtVxHwqRAD8cmuXu5ie/61LpRlqyPaOLsjUmutOEfmTp8i93lJxXLzanBqWpyW6J9nhcBbdj/C46E/Xp+VZ7yTXb7pXJA6DsKaYg2BghlHWuulh+TVu5yVa/PolY2dJ1CGyuZbPVrcq3USbQxXHTGe1dHBrEF3pEtnOYr65lPlwRJEqgZ6En1pnh+w0/xNp+b2EyT242ybPvj0YfX+da9n4YtbF7aCyjXdLMCxx8xABOKqpRs7rYKddtONyhFJbGMGbE0v8Ay0ctyW71HcXVhGvFupP1rJ8RvGviC6ktd6K7BiGG07sDdkducnFVbOOS/eZDMqtHEZBu/iA64rKeEcdUy4YpPRo//9k=",
  "Alex": "data:image/jpeg;base64,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",
  "Charly": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCEk+p/Os3V9Zi0q33uS8jfcjDYLf8A1qvt1OD1rkkk+3eKnkmAZYnMcakdMdP15pDWo+PSvE3iOUXMNkyh8bWaTYFX0wTnFaF14S8W2kH2hrZZGQcSW8gMige38Q/WvQfDy/uY2IyW611TQhoQPL5xUc7NHBI8msLz7baLJlgfusCejDgirqMwI5P51e8S2Edlqa3ESbBcg+YB/fHf6kfyrLRjnnpVp3M2rOwjHnArnLW3YeJZCmNlxueKTsc4z+RyK6IsQwYdRyKzNXH2fUre8XCpNgDHRSAAf1GaUioLqdEmi65cJ9iVDbhCCJ/Mf5h7bTjr61t2UmqXWgS2L3rfaopfLMi/eK4yPxq3petxQaGbm8njRUXG5zxmud0DW7yF5pp7Im2mnVjcrG/AHVsehrPc10HXlpqkeiqdTRVaGUBH8wtvBBHO7kGsxASK7LxZexTaSDE6PHLgoynIPvXGp6VpHYxluMIGTWbrVuZtOd0Hzwnev9RWwbO5UgyQvEpXfukUqNu4Lu57AkZrl7zXZ5NTn01IVjWNmjYnksQcH6dDTEty1oWsW9zcQWeoHMG/IUtja2MV2NlZruETWmntbZyLkXLCTH0Feb6jpf3Z4c7ZOQR2NdH4X8Ja1qciJfXElvZD72DhnHoD2qdDS7RbkvTdTNHblhZQMyQgn73PJ9/SnLntVzxs1jokVs1vtjlLiJLcdDGo6+2OPrmqFgtxe6Ymox2sogd2RWI+8R1I7kc4z61S2M3oz//Z",
  "Checo": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD0GfRriKJn2owUZO1uaz9SDaVpZvZ4TtOAi7gSxPQV1t0f9Fk/3TXIeL5ybfTbcjII3/j0qZ+7FsKceaaic9HDqepXEcrfIoOSucD6VYa71fRZxPbtHIM/OjpkY9q2NPIEAOBwKrao/wApzt9hkZridSVuY9RUIfCaMOpz6paiU3DgHhkBxtPpxUL2YJ6g/jVnwhOryXEQAKsiv07g4P8AMVu6hDE9qwMa9Rzj3rtiuZXPLmnFtE90f9Fl/wB015147+33D2kEI2qkKvGyEhmB+8M/UDpXZ3klxGhLMdrcYrlfErXLWFldqCyW7FHPoGIA/UUqvwOxVBr2qTMbRrW8idhc3MrrJGx2Enj0PJJFVLjw5c+eJ1lMm7ks5zn6HORUd1rN4+oFLOXyWjXZIGHGD6cdavWmrs0DQLvZkXLbx19xXC+ZLmPYtB6Gl4f+0f29awQTMiq4LkHG8DqD6jArv74/6MfqP51wvg2Mz6jcXJkUND275OR+VdLPNOzbSzFc/hXZh01HU8rGTXPZFlp7spIslqm0jg7uRWPrfinw5ZaO9hqtyjGSIoYISJJD7gDoe/OK8g1fxVqeqSPm5ligJO2JXIAHv6msezglv76K0h+/cOIx+JxW1tDFRs73PQ7N7JreO5M0gJQbgDtbkZBI9xg1anhN0Vs9MUz3UhGBnPlr3LHsPrWV4onsbLW7HTrnS38i1hiU3EchEsqdAFGOehwOp9q7PWL2w8KeEHutLjjhMwCWwVcEuR1OecgZJz6Vk6HVnV9Zly2Rxlz4jPhLxVawaeRcpYo0V4TwLhmILj2xgY9CK72Dx1ouqWm63lHYlXwjL9Qa8OkYhyx3OzcknufUmo42KmtbWVkcz953Z//Z",
  "Daniele": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCw00Slg25Spw2VPBqnrN9/Z2nNcKp3khU3KQCapyyX0Ujh792MmC7L8uT+VZmoi4vZLWCS4mlj3H78hbn15q/aaEKndqxXt9Vv2mZy7yjGOc+lbVjfGdUW4gIVVwRsI6DrVqC0gt4giKABx0rqfB+o6ZbTXFpfzW8QlA2eaQMn61z819jslS5Y3Zz7abbuOYhyM9KYumrA26CSSFvVHKn9K2fE9tbpqU8lqiGM7djo3BOORxWLFHPcIxiEgwpOULHA4/D1rdTXVHE4Poc9LrCy5Mku9uPm21JDObuBjBLmSBtygjA9B+NYbW0o6pj8KsW9+dNcM0AOeDk43VMlpoa03FSVySae7kcP50jMxwFPFaUuh3ULwzv+8t5zhSOTkYzn0q1BPDeWcdzHEu5+uAM1Ks11KRDvZgpyEB7+uPWsOfodvsk1e50XiOxj0DRrXy4gElkLIpf5unJPXngH8a5ZfFVxbh4o0/dlSAnmttGfbpVn4h6hNbanpsLLgJYoPUH5mB/lXNotlcugivNjN1WcYAOPUdquKTWpyTbubWpa0bGMme2tt7D5FCnJ/WuMvLyW8uGnlILN6DAA9BVnW5Xl1W4LH7jlAPQDis+tm29zCMUjp9Bl8/TPLjfbLCx/EE5FbunTPDdxzuRhDkhepPavP7W6ms5hLA5Vh+o962H8SzNblVjCSEfeB4HvXNKDvodsKq5bMd4rv3vdXG+UytDGIySenJOP1rHVqYWLMSSSSeSe9KK2Wisczd3c/9k=",
  "Edwin": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD1URgUSFIo2kkYIiAlmJwAB3qfbVbUTGumXLSgNGIm3D2xV3IseZ658Y4baa4ttL0/zNuVjuJX4J9dvp+NZelfGe9gjZNU05Lts5WSJhGfoRjFYM2m2Ru5Ctuu3JxnnisjWbOC3mTZ8oK5wBUqom7GrotK5754a8UaZ4qsjPYSESRgedA/Dxk/zHvWu0ee1eGfCy5ktfHVnEjNsuVeNgDgH5Sfx6V72Vq7mLiUZNcsXt5GhnRmUdCetZfiNUvfBt9FDemOSSLdHtbBDA5xx29a8yl1SVLgrk7e2KuW9y48P6jcxHdMMKFc8AEgH+decq81a63sdEKfNqc7eWlwl5HslcIV5w2Oal1OyFxp8QYKZi4UEnHWqB1e5jKPcxCRNxG8NmmC+k1DUrdVJC+YNqj61vZ7m7lGzR0/gTTrbSfEcV8++R7RX9gWYbR/M/lXbal4zmZ2gSEwgthHz96udjRbeL93EC287Cx+9WfqNpfDUI5rk4hIDDB+5Xl1MVUc3FOy/EKlOKs0jd1HwFcyXXmWs8YjY52s3K0sXw/1AWl7DLexxW9xHsB5J+tegQaVb258xx5kh5wTwDUk0YZgzHO08DsK9OnRv8Rz+1lbQ+cdY8K3ml6xcaY11HMbYjLgFQcgHgH61d0vT4tOPnu4ZwMlj2+ldl4z8PXSalc6wuJI5G/eAdUAAAP09areB9OgvtceW8TfHax+YikZUvnjP05IHtWsoylLlLg4xjzG9/wjt/qOh2m2RLe4dS5icYIyeM++MZqO58Hatdosb3tsgVcZyTk11MkpDK5OSTzT/km68MP4h3qK2CXxQWpksRLW5//Z",
  "Fede": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwB0ktlP4it9ltEFCNuAUc1vtPplvAZJoLeNFHLOAAK5WOwnsNYh892ZpAesZT+dU/GRluLezs4iW8ybLIO+On868+MVLY7pStuVNT8d3s17Imm2VvDbo2FIhDs3PUk8Ulj451S1nQ3tlb3ERPzK0AQkezD+tdX4e+zRMsJEacYwcV1E9pY3Fo0M8ELoRgqwGCK1Tja3KJ05b8xnWupaZf2MV3b28ZilXcuUAP4j1rFuJ7ZPE1tIII9oicEbRiqmkQjTVvdPztSC8kWMMeSpwR/OmT2017rMcUDFX8snITd+lZuCQ02yzfXxu9btsnOzcKq3EbHVIZ2wI0ldQ2PusY+M/wCetSXGlPpmsW4e4E3mbvwwKj1WRBpd1Fu/fvOrwoOrlVyQPwzVUrNaEzdnqPi02CCwur2a8OxgcBgo2t2OcZz+Nb0OmrepZTG82S+QAVXawfjryDXB6dcprFpHaS3pjwSTDvAWUZ6tXUP5OkabBeC4FuVKj7KkgYSdQBgdx14qrGyaauXtYiiisrooBkyrk47/ACj+lZNtcm21+OQHBERFX70SLoZM2fNkdXfPYlgcfh0rMisjf66kAm8nMWd1KVuXUxTvLQzdT8SxG9jng/fNGDtzkDmubvb26vbtbt58TRtldvG3HTAqNF7+tBG2TLAbW4z6V6UKMYLQ4J1ZS3NVPDdtrUI1K2uls3YZdT93d3x6HNbFr4TuNNt/7Qublpp4WUw55CncOareDbiGPVDp90u6G65T/Zcen1H9K9BWxkgeOyBEtrKzOCTyoA5H5kGipSvZxCFVRdpI5rW9aWCRrK5iK7wkiOhyMZzgjsf/AK1U472M6uk8EqsvlYyDUHjTSjpuroULGC4jLJuOdrA/MM/iDWRo80UGt2n2iMSQPII3VumG4/nioq4ePK3EqlWd0mf/2Q==",
  "Gus": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAA0JCgsKCA0LCgsODg0PEyAVExISEyccHhcgLikxMC4pLSwzOko+MzZGNywtQFdBRkxOUlNSMj5aYVpQYEpRUk//2wBDAQ4ODhMREyYVFSZPNS01T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0//wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDidka9FAq5YWT393HbxYXPLMRwq9zVbbn861dHuPsq3BXAkk2qHJwFHJJ/T88UhO9tDdxDpsYt7AImR8xILO3ucfy6UiX6gGC5cOH4KSIQrfgam0ibTnCr9pHmOeFbqxpdUXSnkNrJMzTMduxUJ54/xFY80ue9jX2EeTWRhanYraXS+ST5Mo3Jk5I9R+FRKFUAADPrVzU4ZLe1gjknEpjkZVYA5KkDrnuMEVmBsHnNdKZhZrcpJzWzolmbtJwGAxjgrnJ/zmslEOOlbPh65FveeS4GJTw3oQD/ADrGT00NqaXMrmxYaZJaeWsjgK8gODgfTmtOfTBLfxTxOGEcm8DI+Vh3FMYs10p2h1AyMtjH6VoxSMCrFVCnqc//AFqwUm3udvJG2xy3iq1NvLCzTMxkLEoemepNYWwEA+ora8YXqzalHbJj9yhJPue35AfnWKrZIANdMXocNRe87EsUA29BQ0XG5RgjvTEu9qj2FEF8zsYvISWSVlWPcThTn9aai2JtI6C0muliSWIeYGAOD2rYtnurlQswCD2PNcpZ69BZb4J1lZo5GUMgBDDNbOkazNqd0Y7W38qCNd0ksh5x2AA6ViqM3LlR0e2io8zZS13Q7mXVpJLOPzTMCwQfeJGAcetc/Ir2shjnUxyL1RwQQfpXajxF9lvnlS3MqsojUBsMo9ifU1PfXNhq0SLcxrM6ruYSDJUntmrm3GduXTuYU1zq7ep//9k=",
  "Gyves": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAA0JCgsKCA0LCgsODg0PEyAVExISEyccHhcgLikxMC4pLSwzOko+MzZGNywtQFdBRkxOUlNSMj5aYVpQYEpRUk//2wBDAQ4ODhMREyYVFSZPNS01T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0//wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDoP+EWHe6uDVXUtJtdLtTcXN5cgZwoHVj6CtW11V5ovn+WReGXPQ1ymuXr6j4ugs5ixggQEL2JPJPv2H4Vyo6banPXepXbMw8xwh5Cn0qKLXLqGQfv3eMnlWbr9D1FeirZ2ssf72GNvqorN1PSrKaJkNvGMjqFAIp8ytsX7N9xuj6HpWtWYvLdpCScSKQNyN3BrSi8IW0OTDJNHnrtAGa5LwXfyadqt1ZxybkZckH/AGT/AIE13h1Ftg+bPFKSaM1qZEGi65HOJWeJuMEYxkVVvdIuodaivJVRZnhZRjkZGMH+ddQupE96o6xdb7dJurQtn8DwaCo76mZYXGq+a0d3FCsePldc56dxVVm1i4nyywrCT/COQPfNPkv75p2EVsH6gbjhSMdRUMGoXiwss8RQKPvdic9B3oNrIraPoc02s31xaKpZTgBjgAH/ACa6A6Vq+MeXBx/tGo9PvxpehtdLGzvJ+8cA8nnj9Kl0nxNLqImLwmMI2AT3pORg99CBDc7ctZ3Q9f3Z4qjJq9m8ptdzPIQdyAZwAMnJ+lcfqOs6lqLE3l5NID/Duwo/AcVb8LA/2g+IvM/dlTj+FTwW/D+tdkaHc5ZVuxqQ6l9jTyrxJWt5AGjdc5Ax0yO9RiafWr5YoFaO3UYyc5x61pLYn7MqffVQOQM8VHqV1DpmhSCCMxTyfIMnlif4s+gGainRcnqtDWrX5VZMyxr0aXN3ZH/j2DbYGzwuMDH0OM1sWEF8oaVbKZ0kAKsgBBH1rgG4455rT0fXtR0c4tJ2EZ5MTcofw7fhWlSjf4TGnVt8R//Z",
  "JC": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA8ADwAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAABAUCAwYBB//EADUQAAICAQIDBgIHCQAAAAAAAAECAwQRAAUSITEGEyJBUWFxgQcVMkKhsdEUJUNSU2KRwfH/xAAXAQEBAQEAAAAAAAAAAAAAAAAEBQMC/8QAIBEAAQMEAwEBAAAAAAAAAAAAAQACAxESITEEE0FRcf/aAAwDAQACEQMRAD8AXz9loa+7WaaX0jFdY+cw5uWGeWNTm2B6UDTm5BKqAHwn7RzjA99ONx3anT7S22eyRFPHEytGocP4CPQ6V77vVa7FCtdnkEeWcvHwnI6Y+ROntuNFgSFm92MKzxq7+LhPhAyT8tAFe8bwyunF9lGBXPw8s62fZytUSrHYsPELNle8JkYcRB6Ae2jN3o07EPcTGJg33OIZ+WpEs5vOFSj44LK1Szetj2/6rjk2mIvPXUNZIbmEI6tn36Y0XH9HkzE/vGIqG4WKRk8Jxzzz8jy1PsLPVntbhSkhMkyYEk0h4g6AgBSPbUb21RS3pZRJLApdllriU4zk8wfQ9SPLOiwcjrcYn1NPf1YyNAFyWVOyG/2OHh254xnrKwT89Oq/0fbnws1mxWjUAkqGLEjHw1qhbMkazvM6lhkBWIC+2i6u9VPq+S1bsRwxxMUeSRgBy/7qoOd2EtCOIgMrz59m214a96ew68Ma8hnkAAPLoOWuWtrpbpclt17nDwHGUzw4x5aWxWtuv3bFOXcCKsMritKWKJMpOQG9xqi3Zg2uTG3WzZnnBC14n4kyfve2gvBuOcqpG5lmsIiHeZuzpm/YUjL3JTIXZeiqcD/ODq3dr0u+beu6R5Rkbu7cSnwq33W+BHL4jWYaOWO9JBZtKzDBHEThc88Z8uuj69Zf5pJQf6a4U/M/prqOBpIeN/USR9SR4nFntcb1BIoyalyaUCRv4SjzdepGc8xz0otig6oZtwuTsHLF+4AU+wBbPP1/DQTV1p2TG8kczR44WQ5XmAf9/ho5dxrPWME6MhPLjjbl8SvQ+Wn9UdSWiiFe4UQ+2T7danmoyVRBDYCmNXkL4cZHU46j8tMUg23YK8lsovEOSY+07enPWd3CCCF07gt3boCGb188H01S88lu1Ctuy78JClmOeEZ/TJ0Z0dx3hMZLaNZRdWzUkWdr9aR5ZX4xNFJgj+0g5HD+OmUb0IIbE1C/YiYDKwWYQRIPNeJSRn0yAD7anHH2Th8LT3pfPhwM5+XXl+WlFpZKlruZoZImXxKki8JweYJB9td2jSzqdr//2Q==",
  "JJ": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAAAAAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAGQAAAwEBAQAAAAAAAAAAAAAABAUGAwIH/8QAMRAAAgEDAwIDBwIHAAAAAAAAAQIDAAQRBRIhBjEiQWETFEJRcYGRBxUWIzIzYrHB/8QAGQEAAwEBAQAAAAAAAAAAAAAABAUGAwEC/8QAIREAAQQCAQUBAAAAAAAAAAAAAQACAxEEEjEFFCFxgUH/2gAMAwEAAhEDEQA/AKXR1urWyigke3haGV/5bliRyeMg4xzR2oa2dKs/eZ7iz2g8KpbLeneiooULy5Lf3vInzUVB/qXDLcanp+nwyECRNwyxODuIzXF4abNJFr/6gX2q3jJbTyQxgEARsUBH55+9Z6X1tqdgCV1GcL8Su24EfMZ7GnNj0lp1vbrHJHvYd2PcmmqdM6NNC6SWaHeMZx2rETs4CN7Z9WnfTPUEms6W0yT2+5X5Mm7Jzz5Gj5ZrgxbWuLMblwT4s9vrUj0up6d6n/ZIWd7W8IdeeVwD5+lXN0sEUTSyzMqKMsWkOBWwoi0G62mkAl/AksuZM5ZTxye2D/qpHrSSG76k0u4XeI4FIkO05PJIwO5oW20+JjkoefmKZe4RbEKKNyAldw47jP57UwzMNsMWzXWfSHwZjLLThQ9pa3U8UUphaymwvxgq2PqAcitv4tggYCGBrgH4gQqj0yxrC5s7dpWUW3s3cbTI20BF+eQee5ou7s7GKZHigjkjIXhMAow4Bx64H3FIwI78Kip2tIjSZ4Zer4b+SKWMCzfjbuAbOBgjuME8091q4g1HT5LNXkHtcZb2ZGBnPnSh7SOW2VpEVeMIoIOOcnP14/FKLmziBO2LP2FPsLDjmiDi4j4pvOmfFKQBf1ZxXpXODXUuqPFdWtsgBNy+1tx/pXB7euQKRahqseng+EvL2PyXPmanLvVJriTe8rb1bKMOMc8Ypj1DJjcwxx+Sf1A4MMocJJOAvRGEjguqpIh7hjg1vFFI8TCGOJUA8RLZJ9OKn+neo/fiY3Ki6x41PaT/ACH/AEVTpLLPZToEES+zble/Y1H6lp1KrhI1zLCyluNsaoGOAPzQEtycnxcipvTtTuU0i2lDk7V2ODyCR5/cYpnHcrdQ+0HhOcEfI1bdOki0EQFUFGZ4l2MhPJX/2Q==",
  "Jordi": "data:image/jpeg;base64,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",
  "Luis": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDm7mzkbVDcwS4jAXbuY5BAHP51bTSrvWNelMUxZZW3bnOSo7k1ur4tumHGK2/DmpPqhneY5MRAUfWuFTm3qjt9nBbMqxeFNNtLb54fPfHLyHP6dBXH6/4fhiuGuLUmN2OWRjkH6elemX0qqgUEfNxkVxWv7RJtDgke/Wq1uaOK5TB0m2tIZnbUonlTb8ioDyfetPOgHOdMkx7bv8auQeMryCFIcgmNQuT7U8eNb93VEALMcAeprP2tRacpPsovXmMO28M3SalLaw3iypEgZnk+UZPQfpXbaFpzW+lm1Yqsj7syx85OeB71h/2vp5HGlwfrV7TNchVmCQLBHEC21PfviqU76crRMafJ1uW9M8Ptp813LJcNIrodiMehx1wOlcOdHafzLhpyWVyHLHJ69K6681C8ltLma2Q7t+PPaTCkY6Adxz+dcQL6a1SZJd21jzIWB3HtWho7W1HWsUU2rRR3cyxQPJ80khIUL7kdM4/WptJktB4stYxiW1M4+8Dtxzwc1f0vU9PgsI0n06GaTlmd+pyf8KtnWNKx/wAgi2/I1g6rT+Fi9nfXmMW4EFnaCR7hHkYAqiHJ/GrvhC5ivNcawuG8uO/gaBW7q/DKR+IrknYuTk1PaXElvNFPExWWJg6H0IORXqwpxieZKpJneTq+i6Jd6ddASTRtgofTsR7H1rjdYVZYVkVdqxDdtHr2Feharf2vii9s1hhwn2QSPOg+YOwB2emB3HvXK3OnQwzyJc7mS1f96qDl+eAPrxz71nKk4vRbmsKilF3exzE1/wDZLyW2nVgUbGR+fStPTvs9xqFkomEiSyDdtIyPwrF8QvLcas1zNEIZJkDMijgHkcfgBWepKHKkgjoRQ6KuJVZNH//Z",
  "Manuel": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADAREAAhEBAxEB/8QAGQABAQEBAQEAAAAAAAAAAAAABgUHBAAC/8QAMBAAAgEDAgQFAgUFAAAAAAAAAQIDBAURABIGEyExFCJBUXFhkQcyQoGhFbHB4vH/xAAYAQADAQEAAAAAAAAAAAAAAAACAwQBBf/EACARAAICAgIDAQEAAAAAAAAAAAABAhEDMRIhBCJBURP/2gAMAwEAAhEDEQA/ANSWnji8stT5gMkbdYD0fMgo44zI9UwUeoGsdLsJK3SCN3qL1UTOaGvShgH5RyhJIfqSeg+ANSvyFfSLY+K67ZJo7/eLbUFbrOlxpicZWMRyr9Rjofg4+dHHKmBPx3HQviEFZRJWU+ZKeQZWQdjppMc8tMhGeutMFEqBpGz7aYD9INwdRWpHIwWKGHmMT0GSSB/AP31Nn7VFXjLtskVFyt08hip66GR1GWVT2GpXjovg7B9+uND4hoY6pC69xoowewZyWiv+G9zmlrK+0vIWgMa1MQz0Bztb7+U6qhogyL2LHFV2msgiMUSOr/m3HtpiViW6HLY3t8aMEJ3+3+Pr+YhcSU6qFHTBPU5+vQ+vrqPLJ8qXw6HjKoO/odi4eElRUyVTSzRqC5WZcBTjoNKbssjcNPYIWim5MlMsjqUPdR5WX0z9NN5CHjbt2X/w6ZaHipIiC/iIZIxg9EPRs/Hl0cJE2VffwbcS0KV9XFDIwChC2Nuc6cm46JnFNdmZRXTjGSQPzro2GG7Jb30dgUjVpKmR1jqGBDsg3D21H5CafJF3jNOPFh+4yianmblOuGYc0sE3eh6k/tpSK1b+mepP4Gtnip4dqdckvuwM9s6Y1aE3xdIR8BCKO9i41UqRRQo4VmYDLMMY+2mwXdk2SSqhJxhXVSXGmeikcLySSUGQeumPYqPdoSNa6V5xO0soYHJAJCn5GtsGiJfbvSWuMUcNSKqtqpVWKHHYZ6nPoAMnJ9tDOPNNMKEuMk0R7pco6Knlp6qhMhz0ONyn6jUcVejoOVbM+udWJpSIIFQE9gMaco1sRKV6FHDt3o7bNRWe4xxK0ymRJGH6ycbT/j7ao4uMSRyUpC247Ja+NSwVVjxjONBZoOvHHN2uQMazmBNwIEXl/wC6qWL9FOZ60SPdWrmrKzdUS0zQQFu7SODhVHvtDHRyjUaRkX7KxJFMl2s0byR5l5YV1I/UB11xeLUqR2bTjbIX9GpKSJZ90c1Q5OAhyIv9v7a6mLC4+0tnLzZlL1joBcRzGpvMuDlYsRr+3f8AnOja7Fx0dlt4nudMVE8njI4xtCzHJA9g3fQ/zTN5H//Z",
  "Marko": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCTPh7qdBtvzNVLy+8MWkLyyaHAFQZOGP8AjVSS7ttvE6Z/3qx71ReSpEpDBpFyOxGa53Siv+HN1UkyJvD2s6+z3kMcFlBIcxWy5GF7Z/8Ar0z/AIQ3xFaSHbAHHXcjda7DR9csDcrayPLE7HCs8ZCP9D0rfuNa0q2fyLi/t45T0Rm5rNVJrSxv7Km1e55rod2bjWrSGW38maN9kgGRkg9SOxr0+JOOlcjqlgsXje1u40AWfbuI7sM8/wAq7ROBXZT1jc4aukrHBWXiO6vPECzlItyRFQPLGMGtbUdRmvLeOOdIwglVsqgGPyrz+y1Q2k32qJl3lcYIyBV6PxXNPMkNz5YiZgCQuMe9Y+wio7GqrNy3OkuNP0q2kSZ7goZGB5JwOa130q0vtVa4t77lhkpG3B7fQj2rJggN4EMEv3Rhozgg/mDW19kmh8lnlXag+VVUAr+I7fhXMd+hDrsUdrdaYw/hmVFPbGDVi+1+20+2aSaYR54UkZ5+lc54lv5pNesLZAfs9upcsR1duP5CqGrG3uFjN5cGJFbj3rtpXUDza+stDHtvBmpTxBiGhBGf3pC/p1rZ0nwDbyXUa3M8k78tsT5V4GfqentXU53VZ0uK6+1F7RijJglgOCM5K/j/ACzWj2M1uchFFcNHHcQkqXGSF4we9dN4X0rUddvQlw7C0g5mfP8A46Pc/oKv2vhqO5v2hUmKJsy/7ozyv61u200mjW8ltFEBaFSI8DlXPcnvmuSEG3qddSaS93cxfEGk2WrTbwPJMB2wug6KONuO44rAn8OSyRlHijuID/EM4/xFdDJIR8isB9R2ptvK0T/KxArsscR//9k=",
  "Pepe": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCmb8YMWT5mFKuWAX3/APrUy51C4GyOBfNndQqqvOTXQ/8ACP2mQRLFkdPkH+NN0/TYLLxE1w0iGOG23bgMYZmI/kK8uFSlOVkelKNSK1OYl8GatqFv9qvLwxyMf9W3Yf0rmdR0bVtDl86KQnb0KH+le0XFzbSwPsuIWUfe2sOPrXD69d2sqloZfNCnDFASB7Z6V0Kcr26EulC176mDpmvS3ttuYhXU4ce/rWmNBv7rSG1eO/jWNc/IQd3HWsjwxpkU3iW4tZZFWOWAyIWGehHH867pdDC2htF1LbAc5jCcc/jWFSdCnK0gUKtWCsZDauIsBn5Patvw7ML9rpPM2MUXBBwcZPQ1SvtAuL21hgLqghHDKBk/rVf7BcaABe7yyJ8r89AaalSv7rRSVW3vI2xosUFhqcgmMryIwwzltvfGTXLR6RY3VhGJJQjWy/MAx3c8+verdpb3Gsae015rAtIQzqkcQHzDPIbOK5G9R9I8xLbUDJADhgwGXrZRfcHJJXa0LNrexR640lvwBGUUD61rSa1NFn5HOBn0/wD11h+EomuNXiuARuDgRqTjzCvzMAfpXqDanfk/8gtP+/q1FRUlL33YiE6rXuK5yp1gQpull2j3am2WotreoR2EKFopCRK79NgGW4+gNcrICTySfc1seFFuJNctrW2bY9wSpb+6owW/AgY/Gu2GCpp3ZyTxlRrQZMNS0+x/d2YurNpGO3bvMbAkEHvxjr3rBOm6nq9wEEDQQ5ycjAUV67LpQsHdTCPKm+deSRuPUetY3iZZNI8Py3UjCNpDtgjAx85749hzWkKMrty2InWjZKLPNdUuBDeQ21i5SOy4R1OCX7t+dbmn+MZmCx3pKnp5q9PxH+Fc0Yvl3d/U09IvlFKpQhU+JDp1p0/hZ//Z",
  "Raul": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDufCl1LML+ORt2LmRs+5PNVfHXiWbRbKOxsN7alffLCI1yyjoSPfsPxPaofDszRpq7RtgiRyD+I/xrBmuQnjie6lPmvBYxrDu5Klic/wBfzqp6K5NNczSOYPgfVbhzLf36xSP8xX75yexNV08La5o84u9PvkeWI5XYxVj7V3h+0Sxeaygr2rPuGcNnislN3Ot0o22NX4f64+tzyG5jEd3CpWZCMc8c47V0WgIptbo7RzeS9vcVwvh+ZbLxtJeQBd9xpzbgem4MvP5Vo287tLN+8xm5fgHHWuj4jia5XYbYXdxD9tMQAV5m3gA/3VOK5TxubmHUre8tpXVp4mjZIzt4U/Kc++T+VTaLrl9LqQhnij8qeUggDHzFRjn8K6zULSJ7NGuLWN40cFtwyQCefw6flWM72ujaly3s+p5Xoc/iDUNftrK1vriJ5pAmWYsFHckHrgZNReIYtUtNentLi7ecxsQJCSA49cDpXf6YkGiX11eJbRRSD5UiMuZGU8kgn8Kx7+6hvr4yPaqWdiVVxkn1+lZRndnVKlaOrMvwqlzDraSQuY2kQR7uxG4bgfwxXd2UJaSScSAgXDArg5qHw7YLc7rjy2AtuFCr8oyO9XEhCWUsaTxxSNKXJZ8Ct4PS5x1bXsjyc3Fza3ccl4k0QjlB+bcucc4FdZYeJ9Yktbi2d5re1YMxMoGGUn7vzDOBVmPwTfXoEd5qE0hYf6s8kA/oKyfGOkWmlwLp1vPK0xAM0ssxbjsvPA/+tT5WxHa6PcJqmj/up1EgAZJB3HY/59KwL8/ZXd55EaQcFh0xUVrZFNDs1gb93sxGyNgjPUZ+tZWoaNcS3ltY/atz3LfMWb/Vp/Ex/DNcsI+9ZHdOb5Dd0K5muLGVo7ia3WY5jaNypIHAJx1zU15b3F3BLFCFmlkBQbuST796sQWcMSJHD9xAAoxjAFWbOFbQm4t0bJyEUdB712OMbHBd3P/Z",
  "Vic": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAwADADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDaigXHQVN5SqMkAAdapJq9go5uU/OpYb6z1C4itIplfzXAYA/w9/8AD8anmQ+VmPqGr3rZGmWJdAf9a6cN9BWTb+MbiC5WLU7EKhOC6qQR+HevQtQWOCPCJhMYwOlcZrcK8oyhs8kdaw9q7nV9XXLc2Jrm2js/tRdTEV3Bh0IrLtte0++naGFsMBkbhjNZ2hX9o+l3Gn30g2QzFUDHqp5x+BzTY10m2u2eARou0YJOTmtHLU5eR3NS78HaPHp1zciOTdFA0i/PxkA1jeDbE3bvcwu9u8RQs0Zw23nIHft+Wa9An066uNNms/Nsh50Ji3+f0yOuMe9ZfhnwpdeG7ppft9tNGybCqt82exH+e9Z86sdEYvm1M+ax1efUGEOrZTA2jcXCnuSCeRjNcn5eoXkkpl1AlkJVgz7Qcd8Z4rvXubiL7ZJHH+9Zip+TC4+uOtcVE89veyRSDzGYksxTAUetTd2udDitjK+whZpA7GTOGGevf86f9ij/AOeZro9M8M3Ws2zXUVzbxKJCuJH2kkD+XNXv+EHvwP8Aj+sf+/8ASc11MeXsdZFCCOlSNAgUlsAdyTiuN1Dx3KgKadbqq9pZeSR67e341mafq1xqOrW8+q3btGj7yD90Y+6Ao9TgfjXoqk2cDnY7WcrFpMxE25Tkh1P38HGfw6fhXn+rsAzLHIXdyPm9BXXaU7vpNzpcwO6KVwmR1BYn+tZlxZafb5KOJZkPzHHyxgd89Cf5Vywp80mkds6nLHVlfRvENtp95Hol8yxAxq0ch4CsSSVY/lg11ZiUjI714nfzNeXs10ed7E/Qdv0rU0bxJq2jhRBOXhHWGX5l/wDrfhXR7NdDk5mf/9k=",
  "Yolito": "data:image/jpeg;base64,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",
};

// ============================================================
// ENGINE
// ============================================================
var QW = { min: 8, max: 12 };

function scenario(T, N, P, d) {
  if (N <= 0 || P <= 0 || d <= 0) return null;
  var S = P * 4, rounds = Math.floor(T / d);
  if (rounds <= 0) return null;
  var ts = rounds * S, gpp = ts / N, gf = Math.floor(gpp), rem = ts % N;
  return { duration: d, rounds: rounds, totalSlots: ts, gamesPerPlayer: gpp, gamesFloor: gf, gamesCeil: gf + (rem ? 1 : 0), remainder: rem, gap: rem === 0 ? 0 : 1, usedTime: rounds * d, deadTime: T - rounds * d, S: S, activityPct: Math.round(Math.min(100, (S / N) * 100) * 10) / 10 };
}

// Scenario with seconds precision (durationSec = total seconds per game)
function scenarioSec(Tsec, N, P, dSec) {
  if (N <= 0 || P <= 0 || dSec <= 0) return null;
  var S = P * 4, rounds = Math.floor(Tsec / dSec);
  if (rounds <= 0) return null;
  var ts = rounds * S, gpp = ts / N, gf = Math.floor(gpp), rem = ts % N;
  var usedSec = rounds * dSec;
  var deadSec = Tsec - usedSec;
  var dMin = Math.round(dSec / 60 * 100) / 100;
  return { duration: dMin, durationSec: dSec, rounds: rounds, totalSlots: ts, gamesPerPlayer: gpp, gamesFloor: gf, gamesCeil: gf + (rem ? 1 : 0), remainder: rem, gap: rem === 0 ? 0 : 1, usedTime: Math.round(usedSec / 60 * 100) / 100, usedTimeSec: usedSec, deadTime: Math.round(deadSec / 60 * 100) / 100, deadTimeSec: deadSec, S: S, activityPct: Math.round(Math.min(100, (S / N) * 100) * 10) / 10 };
}

function findOptimal(T, N, P) {
  if (N < 4 || P < 1) return null;
  var Tsec = T * 60;
  var cs = [];
  // First: try integer minutes 6-12
  for (var d = QW.min; d <= QW.max; d++) { var s = scenario(T, N, P, d); if (s && s.rounds > 0) cs.push(s); }
  if (!cs.length) return null;
  var perf = cs.filter(function(c) { return c.remainder === 0; });
  if (perf.length) { perf.sort(function(a, b) { return b.rounds - a.rounds; }); var best = Object.assign({}, perf[0], { eq: "perfect" }); best.durationSec = best.duration * 60; best.usedTimeSec = best.usedTime * 60; best.deadTimeSec = best.deadTime * 60; return best; }
  // No perfect integer solution: try seconds-precision to find exact-fit with 0 dead time
  // For each possible round count, compute exact duration in seconds
  var secCandidates = [];
  var minRounds = Math.floor(Tsec / (QW.max * 60));
  var maxRounds = Math.floor(Tsec / (QW.min * 60));
  for (var r = Math.max(1, minRounds); r <= maxRounds; r++) {
    var dSec = Math.floor(Tsec / r); // floor to stay within time
    if (dSec < QW.min * 60 || dSec > QW.max * 60) continue;
    var sc = scenarioSec(Tsec, N, P, dSec);
    if (sc && sc.rounds > 0 && sc.remainder === 0) {
      secCandidates.push(sc);
    }
    // Also try exact division (T*60 / r) if integer
    if (Tsec % r === 0) {
      var exactD = Tsec / r;
      if (exactD >= QW.min * 60 && exactD <= QW.max * 60) {
        var sc2 = scenarioSec(Tsec, N, P, exactD);
        if (sc2 && sc2.rounds > 0 && sc2.remainder === 0) secCandidates.push(sc2);
      }
    }
  }
  if (secCandidates.length) {
    // Pick one with most rounds (more games) and least dead time
    secCandidates.sort(function(a, b) { return a.deadTimeSec !== b.deadTimeSec ? a.deadTimeSec - b.deadTimeSec : b.rounds - a.rounds; });
    return Object.assign({}, secCandidates[0], { eq: "perfect" });
  }
  // Fallback: best integer minute option
  cs.sort(function(a, b) { return a.remainder !== b.remainder ? a.remainder - b.remainder : b.rounds - a.rounds; });
  var fb = Object.assign({}, cs[0], { eq: "offset" });
  fb.durationSec = fb.duration * 60; fb.usedTimeSec = fb.usedTime * 60; fb.deadTimeSec = fb.deadTime * 60;
  return fb;
}

// Format seconds as M:SS
function fmtDurationSec(sec) {
  var m = Math.floor(sec / 60);
  var s = sec % 60;
  return m + ":" + String(s).padStart(2, "0");
}

function findExtension(T, N, P, cfg) {
  if (!cfg) return null;
  var S = P * 4;
  // Check if current T already has integer-minute perfect solution (remainder=0)
  for (var d0 = QW.min; d0 <= QW.max; d0++) {
    var s0 = scenario(T, N, P, d0);
    if (s0 && s0.remainder === 0) return null; // already achievable with integers
  }
  // Try adding 1-30 extra minutes to find first T' with integer-minute remainder=0
  for (var extra = 1; extra <= 30; extra++) {
    var Tnew = T + extra;
    for (var d = QW.min; d <= QW.max; d++) {
      var s = scenario(Tnew, N, P, d);
      if (s && s.remainder === 0) {
        return { extra: extra, totalTime: Tnew, duration: d, rounds: s.rounds, games: s.gamesFloor, total: Tnew };
      }
    }
  }
  return null;
}

// ============================================================
// SHARED ANTI-REPETITION TRACKER (used across BOTH phases)
// ============================================================
var GlobalTracker = {
  pairCount: {},
  opponentCount: {},
  matchUsed: {},
  pairKey: function(a, b) { return Math.min(a, b) + "-" + Math.max(a, b); },
  matchKey: function(ids) { return ids.slice().sort(function(x, y) { return x - y; }).join(","); },
  reset: function() { this.pairCount = {}; this.opponentCount = {}; this.matchUsed = {}; },
  record: function(t1a, t1b, t2a, t2b) {
    var pk1 = this.pairKey(t1a, t1b), pk2 = this.pairKey(t2a, t2b);
    var ok1 = this.pairKey(t1a, t2a), ok2 = this.pairKey(t1a, t2b);
    var ok3 = this.pairKey(t1b, t2a), ok4 = this.pairKey(t1b, t2b);
    var mk = this.matchKey([t1a, t1b, t2a, t2b]);
    this.pairCount[pk1] = (this.pairCount[pk1] || 0) + 1;
    this.pairCount[pk2] = (this.pairCount[pk2] || 0) + 1;
    this.opponentCount[ok1] = (this.opponentCount[ok1] || 0) + 1;
    this.opponentCount[ok2] = (this.opponentCount[ok2] || 0) + 1;
    this.opponentCount[ok3] = (this.opponentCount[ok3] || 0) + 1;
    this.opponentCount[ok4] = (this.opponentCount[ok4] || 0) + 1;
    this.matchUsed[mk] = (this.matchUsed[mk] || 0) + 1;
  },
  score: function(t1a, t1b, t2a, t2b) {
    var pk1 = this.pairKey(t1a, t1b), pk2 = this.pairKey(t2a, t2b);
    var ok1 = this.pairKey(t1a, t2a), ok2 = this.pairKey(t1a, t2b);
    var ok3 = this.pairKey(t1b, t2a), ok4 = this.pairKey(t1b, t2b);
    var mk = this.matchKey([t1a, t1b, t2a, t2b]);
    var s = 0;
    s += (this.pairCount[pk1] || 0) * 200;
    s += (this.pairCount[pk2] || 0) * 200;
    s += (this.opponentCount[ok1] || 0) * 30;
    s += (this.opponentCount[ok2] || 0) * 30;
    s += (this.opponentCount[ok3] || 0) * 30;
    s += (this.opponentCount[ok4] || 0) * 30;
    s += (this.matchUsed[mk] || 0) * 10000;
    return s;
  }
};

function shuffleArray(arr) {
  var a = arr.slice();
  for (var i = a.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
  }
  return a;
}

// ============================================================
// ASSIGN COURTS - LEGACY (used by Phase 2)
// Minimizes repetition via GlobalTracker scoring
// ============================================================
function assignCourtsOptimal(ps, nc, phase, tierLabels) {
  var bestCourts = null, bestScore = Infinity;
  var NUM_ATTEMPTS = 100;
  for (var attempt = 0; attempt < NUM_ATTEMPTS; attempt++) {
    var cand;
    if (attempt === 0) {
      var half = Math.ceil(ps.length / 2);
      var top = ps.slice(0, half), bot = ps.slice(half).reverse();
      cand = [];
      for (var ci = 0; ci < Math.max(top.length, bot.length); ci++) {
        if (top[ci]) cand.push(top[ci]);
        if (bot[ci]) cand.push(bot[ci]);
      }
    } else if (attempt < 10) {
      var h2 = Math.ceil(ps.length / 2);
      var t2 = ps.slice(0, h2), b2 = ps.slice(h2).reverse();
      var off = attempt % t2.length;
      t2 = t2.slice(off).concat(t2.slice(0, off));
      var off2 = (attempt * 3) % Math.max(1, b2.length);
      b2 = b2.slice(off2).concat(b2.slice(0, off2));
      cand = [];
      for (var ci2 = 0; ci2 < Math.max(t2.length, b2.length); ci2++) {
        if (t2[ci2]) cand.push(t2[ci2]);
        if (b2[ci2]) cand.push(b2[ci2]);
      }
    } else {
      cand = shuffleArray(ps);
    }
    var courts = [], totalScore = 0, valid = true;
    for (var c = 0; c < nc; c++) {
      var g = cand.slice(c * 4, c * 4 + 4);
      if (g.length < 4) { valid = false; break; }
      var arrs = [
        { t1: [g[0], g[3]], t2: [g[1], g[2]] },
        { t1: [g[0], g[1]], t2: [g[2], g[3]] },
        { t1: [g[0], g[2]], t2: [g[1], g[3]] }
      ];
      var ba = arrs[0], bs = Infinity;
      for (var ai = 0; ai < arrs.length; ai++) {
        var sc = GlobalTracker.score(arrs[ai].t1[0].id, arrs[ai].t1[1].id, arrs[ai].t2[0].id, arrs[ai].t2[1].id);
        if (sc < bs) { bs = sc; ba = arrs[ai]; }
      }
      totalScore += bs;
      courts.push({ court: c + 1, t1: ba.t1, t2: ba.t2, tier: (tierLabels && tierLabels[c]) || "Social", phase: phase });
    }
    if (valid && courts.length === nc && totalScore < bestScore) {
      bestScore = totalScore;
      bestCourts = courts;
      if (totalScore === 0) break;
    }
  }
  if (!bestCourts) {
    bestCourts = [];
    for (var fb = 0; fb < nc; fb++) {
      var bi = fb * 4;
      bestCourts.push({ court: fb + 1, t1: [ps[bi], ps[bi + 3]], t2: [ps[bi + 1], ps[bi + 2]], tier: (tierLabels && tierLabels[fb]) || "Social", phase: phase });
    }
  }
  bestCourts.forEach(function(ct) {
    GlobalTracker.record(ct.t1[0].id, ct.t1[1].id, ct.t2[0].id, ct.t2[1].id);
  });
  return bestCourts;
}

// ============================================================
// MINDELTA GREEDY BALANCER (Phase 1)
// Minimizes rating delta between teams while avoiding pair repeats.
// For each round: tries all possible rest candidates, all court
// partitions, and all 2v2 splits. Picks the config with the
// lowest maxDelta (worst court), tiebreaking by totalDelta.
// Complexity: ~N * C(N-1,4) * 9 per round  instant for N20.
// ============================================================
function _combinations(arr, k) {
  var result = [];
  function bt(start, combo) {
    if (combo.length === k) { result.push(combo.slice()); return; }
    for (var i = start; i < arr.length; i++) {
      combo.push(arr[i]);
      bt(i + 1, combo);
      combo.pop();
    }
  }
  bt(0, []);
  return result;
}

function _getRating(player) {
  return (player.stats && typeof player.stats.rating === "number") ? player.stats.rating : 0;
}

function _teamRating(players) {
  var s = 0;
  for (var i = 0; i < players.length; i++) s += _getRating(players[i]);
  return s;
}

function _pairSortKey(a, b) {
  return Math.min(a.id, b.id) + "-" + Math.max(a.id, b.id);
}

// Find the best balanced round for a set of 8 players on 2 courts
function _findBestRound(players8, usedPairKeys, numCourts) {
  var n = players8.length;
  if (n < numCourts * 4) return null;

  // ====================================================================
  // STRATEGY: Exhaustive for 1-2 courts, Greedy+Monte Carlo for 3+
  // ====================================================================

  // --- Evaluate a candidate set of court configs ---
  function evaluateConfig(courtConfigs) {
    var maxDelta = 0, totalDelta = 0, pairRepeatPenalty = 0, opponentVariety = 0;
    for (var cc = 0; cc < courtConfigs.length; cc++) {
      var c = courtConfigs[cc];
      var pk1 = _pairSortKey(c.t1[0], c.t1[1]);
      var pk2 = _pairSortKey(c.t2[0], c.t2[1]);
      if (usedPairKeys[pk1]) pairRepeatPenalty++;
      if (usedPairKeys[pk2]) pairRepeatPenalty++;
      var gScore = GlobalTracker.score(c.t1[0].id, c.t1[1].id, c.t2[0].id, c.t2[1].id);
      opponentVariety += gScore;
      if (c.delta > maxDelta) maxDelta = c.delta;
      totalDelta += c.delta;
    }
    return { maxDelta: maxDelta, totalDelta: totalDelta, pairRep: pairRepeatPenalty, oppVar: opponentVariety };
  }

  function isBetter(score, best) {
    if (score.pairRep < best.pairRep) return true;
    if (score.pairRep > best.pairRep) return false;
    if (score.maxDelta < best.maxDelta) return true;
    if (score.maxDelta > best.maxDelta) return false;
    if (score.totalDelta < best.totalDelta) return true;
    if (score.totalDelta > best.totalDelta) return false;
    return score.oppVar < best.oppVar;
  }

  // --- Best 2v2 split for a group of 4 players ---
  function bestSplit4(group) {
    var splits = [
      { t1: [group[0], group[1]], t2: [group[2], group[3]] },
      { t1: [group[0], group[2]], t2: [group[1], group[3]] },
      { t1: [group[0], group[3]], t2: [group[1], group[2]] }
    ];
    var best = null, bestD = Infinity;
    for (var i = 0; i < splits.length; i++) {
      var r1 = _teamRating(splits[i].t1), r2 = _teamRating(splits[i].t2);
      var d = Math.abs(r1 - r2);
      // Also check pair repeats
      var pk1 = _pairSortKey(splits[i].t1[0], splits[i].t1[1]);
      var pk2 = _pairSortKey(splits[i].t2[0], splits[i].t2[1]);
      var rep = (usedPairKeys[pk1] ? 1000 : 0) + (usedPairKeys[pk2] ? 1000 : 0);
      var score = rep + d;
      if (score < bestD) { bestD = score; best = splits[i]; best.delta = d; }
    }
    return best;
  }

  // --- Build court configs from a partition (array of groups of 4 indices) ---
  function buildFromPartition(partition) {
    var configs = [];
    for (var ci = 0; ci < partition.length; ci++) {
      var group = partition[ci].map(function(idx) { return players8[idx]; });
      var split = bestSplit4(group);
      if (split) configs.push({ t1: split.t1, t2: split.t2, delta: split.delta });
    }
    return configs.length === partition.length ? configs : null;
  }

  // ====================================================================
  // FOR 1-2 COURTS: Exhaustive (guaranteed optimal, fast)
  // ====================================================================
  if (numCourts <= 2) {
    var indices = [];
    for (var i = 0; i < n; i++) indices.push(i);
    var court1Groups = _combinations(indices, 4);
    var seen = {};
    var best = null;
    var bestScore = { pairRep: Infinity, maxDelta: Infinity, totalDelta: Infinity, oppVar: Infinity };

    for (var gi = 0; gi < court1Groups.length; gi++) {
      var c1idx = court1Groups[gi];
      var c2idx = [];
      var inC1 = {};
      for (var j = 0; j < c1idx.length; j++) inC1[c1idx[j]] = true;
      for (var k = 0; k < n; k++) { if (!inC1[k]) c2idx.push(k); }

      if (numCourts === 2) {
        var key1 = c1idx.join(","), key2 = c2idx.join(",");
        var dedupKey = key1 < key2 ? key1 + "|" + key2 : key2 + "|" + key1;
        if (seen[dedupKey]) continue;
        seen[dedupKey] = true;
      }

      var courtGroups = [c1idx];
      if (numCourts >= 2) courtGroups.push(c2idx);

      // Generate splits for each court
      var courtSplits = [];
      for (var ci = 0; ci < courtGroups.length; ci++) {
        var g = courtGroups[ci];
        courtSplits.push([
          { t1: [g[0], g[1]], t2: [g[2], g[3]] },
          { t1: [g[0], g[2]], t2: [g[1], g[3]] },
          { t1: [g[0], g[3]], t2: [g[1], g[2]] }
        ]);
      }
      var splitCombos = [[]];
      for (var si = 0; si < courtSplits.length; si++) {
        var newCombos = [];
        for (var ci2 = 0; ci2 < splitCombos.length; ci2++) {
          for (var sj = 0; sj < courtSplits[si].length; sj++) {
            newCombos.push(splitCombos[ci2].concat([courtSplits[si][sj]]));
          }
        }
        splitCombos = newCombos;
      }

      for (var sci = 0; sci < splitCombos.length; sci++) {
        var combo = splitCombos[sci];
        var courtConfigs = [];
        for (var cc = 0; cc < combo.length; cc++) {
          var t1p = [players8[combo[cc].t1[0]], players8[combo[cc].t1[1]]];
          var t2p = [players8[combo[cc].t2[0]], players8[combo[cc].t2[1]]];
          var r1 = _teamRating(t1p), r2 = _teamRating(t2p);
          courtConfigs.push({ t1: t1p, t2: t2p, delta: Math.abs(r1 - r2) });
        }
        var score = evaluateConfig(courtConfigs);
        if (isBetter(score, bestScore)) {
          bestScore = score;
          best = courtConfigs;
        }
      }
    }
    return best;
  }

  // ====================================================================
  // FOR 3+ COURTS: Greedy balanced partition + Monte Carlo refinement
  // ====================================================================
  var best = null;
  var bestScore = { pairRep: Infinity, maxDelta: Infinity, totalDelta: Infinity, oppVar: Infinity };

  // Sort players by rating
  var byRating = [];
  for (var i = 0; i < n; i++) byRating.push(i);
  byRating.sort(function(a, b) {
    var ra = players8[a].stats ? players8[a].stats.rating : (players8[a].rating || 0);
    var rb = players8[b].stats ? players8[b].stats.rating : (players8[b].rating || 0);
    return rb - ra; // descending
  });

  // --- Strategy 1: Snake draft (balanced) ---
  function snakeDraft(order) {
    var groups = [];
    for (var g = 0; g < numCourts; g++) groups.push([]);
    for (var i = 0; i < order.length; i++) {
      // Snake: 0,1,2,3,3,2,1,0,0,1,2,3...
      var cycle = Math.floor(i / numCourts);
      var pos = i % numCourts;
      var gIdx = (cycle % 2 === 0) ? pos : (numCourts - 1 - pos);
      groups[gIdx].push(order[i]);
    }
    return groups;
  }

  // --- Strategy 2: Block partition (tiered) ---
  function blockPartition(order) {
    var groups = [];
    for (var g = 0; g < numCourts; g++) groups.push(order.slice(g * 4, (g + 1) * 4));
    return groups;
  }

  // --- Strategy 3: Random perturbation of snake ---
  function perturbedPartition(order, numSwaps) {
    var shuffled = order.slice();
    for (var s = 0; s < numSwaps; s++) {
      var a = Math.floor(Math.random() * shuffled.length);
      var b = Math.floor(Math.random() * shuffled.length);
      var tmp = shuffled[a]; shuffled[a] = shuffled[b]; shuffled[b] = tmp;
    }
    return snakeDraft(shuffled);
  }

  // Try each partition strategy, keep best
  function tryPartition(groups) {
    if (!groups.every(function(g) { return g.length === 4; })) return;
    var configs = buildFromPartition(groups);
    if (!configs) return;
    var score = evaluateConfig(configs);
    if (isBetter(score, bestScore)) {
      bestScore = score;
      best = configs;
    }
  }

  // Deterministic strategies
  tryPartition(snakeDraft(byRating));
  tryPartition(blockPartition(byRating));

  // Reversed snake
  var byRatingAsc = byRating.slice().reverse();
  tryPartition(snakeDraft(byRatingAsc));

  // Monte Carlo: random perturbations (fast  500 iterations takes ~20ms)
  var MC_ITERATIONS = 500;
  for (var mc = 0; mc < MC_ITERATIONS; mc++) {
    var numSwaps = 1 + Math.floor(Math.random() * 4);
    tryPartition(perturbedPartition(byRating, numSwaps));
  }

  // If pairRep > 0 (repeats found), do extra iterations focused on avoiding repeats
  if (bestScore.pairRep > 0) {
    for (var mc2 = 0; mc2 < 500; mc2++) {
      var numSwaps2 = 1 + Math.floor(Math.random() * 6);
      tryPartition(perturbedPartition(byRating, numSwaps2));
    }
  }

  return best;
}

// Build Phase 1 rounds using MinDelta Greedy Balancer
function buildPhase1Matches(cfg, players, numCourts) {
  if (!cfg || !players.length) return { rounds: [], counts: {} };
  GlobalTracker.reset();
  var sorted = players.slice().sort(function(a, b) { return a.ranking - b.ranking; });
  var N = sorted.length;
  var S = numCourts * 4; // players per round
  var counts = {};
  sorted.forEach(function(p) { counts[p.id] = 0; });
  var usedPairKeys = {}; // track team pairs across rounds
  var rounds = [];
  var p1Count = Math.ceil(cfg.rounds * 0.5);

  for (var r = 0; r < p1Count; r++) {
    // Determine who plays and who rests based on equity
    var priority = sorted.slice().sort(function(a, b) {
      return counts[a.id] !== counts[b.id] ? counts[a.id] - counts[b.id] : a.ranking - b.ranking;
    });

    // If all can play (N <= S), no one rests
    if (N <= S) {
      var playing = priority.slice(0, N);
      var resting = [];
      playing.forEach(function(p) { counts[p.id]++; });
      var ps = playing.slice().sort(function(a, b) { return a.ranking - b.ranking; });
      var nc = Math.min(numCourts, Math.floor(ps.length / 4));
      var roundResult = _findBestRound(ps, usedPairKeys, nc);
      if (roundResult) {
        var courtList = [];
        for (var ci = 0; ci < roundResult.length; ci++) {
          var rc = roundResult[ci];
          var pk1 = _pairSortKey(rc.t1[0], rc.t1[1]);
          var pk2 = _pairSortKey(rc.t2[0], rc.t2[1]);
          usedPairKeys[pk1] = (usedPairKeys[pk1] || 0) + 1;
          usedPairKeys[pk2] = (usedPairKeys[pk2] || 0) + 1;
          GlobalTracker.record(rc.t1[0].id, rc.t1[1].id, rc.t2[0].id, rc.t2[1].id);
          courtList.push({ court: ci + 1, t1: rc.t1, t2: rc.t2, tier: "Social", phase: 1 });
        }
        rounds.push({ round: r + 1, phase: 1, phaseLabel: "Mezcla Social", courts: courtList, resting: resting, playing: playing });
      }
    } else {
      // Need to choose who rests  try each candidate, pick best balance
      // Candidates: players with fewest games (maintain equity)
      var minCount = counts[priority[0].id];
      var restCandidates = [];
      // How many must rest this round
      var numResting = N - S;

      // For simplicity with 1 resting player (most common: 9 players, 2 courts)
      // Try each eligible candidate and pick the one yielding best balance
      if (numResting === 1) {
        var bestRoundResult = null;
        var bestRestPlayer = null;
        var bestMaxDelta = Infinity;
        var bestTotalDelta = Infinity;
        var bestRepScore = Infinity;
        var bestEquityPen = Infinity;

        // Eligible rest candidates: try all with max play count (equity),
        // but if delta is significantly better with other candidate, allow it
        var maxPlayCount = 0;
        for (var pc = 0; pc < priority.length; pc++) {
          if (counts[priority[pc].id] > maxPlayCount) maxPlayCount = counts[priority[pc].id];
        }
        // Try equity-preferred first; for 3+ courts limit candidates to keep it fast
        var equityRest = priority.filter(function(p) { return counts[p.id] >= maxPlayCount; });
        var allRest = priority.slice();
        // For 3+ courts, only try equity candidates (fast); for 1-2 courts try all (exhaustive)
        var eligibleRest = numCourts >= 3 ? equityRest : allRest;
        if (eligibleRest.length === 0) eligibleRest = allRest.slice(0, Math.min(allRest.length, 5));

        for (var ri = 0; ri < eligibleRest.length; ri++) {
          var restP = eligibleRest[ri];
          var avail = sorted.filter(function(p) { return p.id !== restP.id; });
          avail.sort(function(a, b) { return a.ranking - b.ranking; });
          var nc2 = Math.min(numCourts, Math.floor(avail.length / 4));
          var result = _findBestRound(avail, usedPairKeys, nc2);
          if (!result) continue;

          // Evaluate this configuration
          var maxD = 0, totalD = 0, pairRep = 0;
          for (var cci = 0; cci < result.length; cci++) {
            if (result[cci].delta > maxD) maxD = result[cci].delta;
            totalD += result[cci].delta;
            var pka = _pairSortKey(result[cci].t1[0], result[cci].t1[1]);
            var pkb = _pairSortKey(result[cci].t2[0], result[cci].t2[1]);
            pairRep += (usedPairKeys[pka] || 0) + (usedPairKeys[pkb] || 0);
          }

          var better = false;
          // Equity penalty: soft adjustment  prefer resting players who played more
          var equityPenalty = (maxPlayCount - counts[restP.id]);
          // FIXED PRIORITY:
          // 1 pairRep: HARD  no repeated team-pairs
          // 2 equityPenalty: prefer equitable rest distribution
          // 3 maxDelta: PRIMARY  minimize worst-court gap
          // 4 totalDelta: minimize sum of gaps
          if (pairRep < bestRepScore) { better = true; }
          else if (pairRep === bestRepScore) {
            if (equityPenalty < bestEquityPen) { better = true; }
            else if (equityPenalty === bestEquityPen) {
              if (maxD < bestMaxDelta) { better = true; }
              else if (maxD === bestMaxDelta && totalD < bestTotalDelta) { better = true; }
            }
          }
          if (better) {
            bestMaxDelta = maxD;
            bestTotalDelta = totalD;
            bestRepScore = pairRep;
            bestEquityPen = equityPenalty;
            bestRoundResult = result;
            bestRestPlayer = restP;
          }
        }

        if (bestRoundResult && bestRestPlayer) {
          var playingList = sorted.filter(function(p) { return p.id !== bestRestPlayer.id; });
          var restingList = [bestRestPlayer];
          playingList.forEach(function(p) { counts[p.id]++; });

          var courtList2 = [];
          for (var ci2 = 0; ci2 < bestRoundResult.length; ci2++) {
            var rc2 = bestRoundResult[ci2];
            var pka2 = _pairSortKey(rc2.t1[0], rc2.t1[1]);
            var pkb2 = _pairSortKey(rc2.t2[0], rc2.t2[1]);
            usedPairKeys[pka2] = (usedPairKeys[pka2] || 0) + 1;
            usedPairKeys[pkb2] = (usedPairKeys[pkb2] || 0) + 1;
            GlobalTracker.record(rc2.t1[0].id, rc2.t1[1].id, rc2.t2[0].id, rc2.t2[1].id);
            courtList2.push({ court: ci2 + 1, t1: rc2.t1, t2: rc2.t2, tier: "Social", phase: 1 });
          }
          rounds.push({ round: r + 1, phase: 1, phaseLabel: "Mezcla Social", courts: courtList2, resting: restingList, playing: playingList });
        }
      } else {
        // Multiple resting: fallback to equity-based selection + MinDelta for court assignment
        var playingFB = priority.slice(0, S);
        var restingFB = priority.slice(S);
        playingFB.forEach(function(p) { counts[p.id]++; });
        var psFB = playingFB.slice().sort(function(a, b) { return a.ranking - b.ranking; });
        var ncFB = Math.min(numCourts, Math.floor(psFB.length / 4));
        var resultFB = _findBestRound(psFB, usedPairKeys, ncFB);
        if (resultFB) {
          var courtListFB = [];
          for (var ciFB = 0; ciFB < resultFB.length; ciFB++) {
            var rcFB = resultFB[ciFB];
            var pkaFB = _pairSortKey(rcFB.t1[0], rcFB.t1[1]);
            var pkbFB = _pairSortKey(rcFB.t2[0], rcFB.t2[1]);
            usedPairKeys[pkaFB] = (usedPairKeys[pkaFB] || 0) + 1;
            usedPairKeys[pkbFB] = (usedPairKeys[pkbFB] || 0) + 1;
            GlobalTracker.record(rcFB.t1[0].id, rcFB.t1[1].id, rcFB.t2[0].id, rcFB.t2[1].id);
            courtListFB.push({ court: ciFB + 1, t1: rcFB.t1, t2: rcFB.t2, tier: "Social", phase: 1 });
          }
          rounds.push({ round: r + 1, phase: 1, phaseLabel: "Mezcla Social", courts: courtListFB, resting: restingFB, playing: playingFB });
        } else {
          // Ultimate fallback: use legacy assignCourtsOptimal
          var courtListLeg = assignCourtsOptimal(psFB, ncFB, 1, null);
          rounds.push({ round: r + 1, phase: 1, phaseLabel: "Mezcla Social", courts: courtListLeg, resting: restingFB, playing: playingFB });
        }
      }
    }
  }
  return { rounds: rounds, counts: counts };
}

// Compute "day ranking" from Phase 1 scores
function computeDayRanking(p1Rounds, scores, players) {
  var stats = {};
  players.forEach(function(p) { stats[p.id] = { id: p.id, wins: 0, losses: 0, played: 0, pointsFor: 0, pointsAgainst: 0, diff: 0, player: p }; });
  p1Rounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      var sk = r.round + "-" + c.court;
      var sc = scores[sk];
      if (!sc || sc.s1 === "" || sc.s2 === "") return;
      var s1n = parseInt(sc.s1), s2n = parseInt(sc.s2);
      if (isNaN(s1n) || isNaN(s2n)) return;
      c.t1.forEach(function(p) {
        if (!stats[p.id]) return;
        stats[p.id].played++;
        stats[p.id].pointsFor += s1n;
        stats[p.id].pointsAgainst += s2n;
        if (s1n > s2n) stats[p.id].wins++;
        else if (s2n > s1n) stats[p.id].losses++;
      });
      c.t2.forEach(function(p) {
        if (!stats[p.id]) return;
        stats[p.id].played++;
        stats[p.id].pointsFor += s2n;
        stats[p.id].pointsAgainst += s1n;
        if (s2n > s1n) stats[p.id].wins++;
        else if (s1n > s2n) stats[p.id].losses++;
      });
    });
  });
  var ranked = Object.values(stats);
  ranked.forEach(function(s) { s.diff = s.pointsFor - s.pointsAgainst; });
  ranked.sort(function(a, b) {
    if (b.wins !== a.wins) return b.wins - a.wins;
    if (b.diff !== a.diff) return b.diff - a.diff;
    return a.player.ranking - b.player.ranking;
  });
  ranked.forEach(function(s, i) { s.dayRank = i + 1; });
  return ranked;
}

// ============================================================
// MinDelta for a SINGLE COURT (4 players  best 2v2 split)
// Used as fallback when only 1 court available.
// ============================================================
function _findBestSplit4(fourPlayers, usedPairKeys) {
  var p = fourPlayers;
  var splits = [
    { t1: [p[0], p[1]], t2: [p[2], p[3]] },
    { t1: [p[0], p[2]], t2: [p[1], p[3]] },
    { t1: [p[0], p[3]], t2: [p[1], p[2]] }
  ];
  var best = null;
  var bestRep = Infinity, bestDelta = Infinity, bestOppVar = Infinity;
  for (var i = 0; i < splits.length; i++) {
    var s = splits[i];
    var pk1 = _pairSortKey(s.t1[0], s.t1[1]);
    var pk2 = _pairSortKey(s.t2[0], s.t2[1]);
    var rep = (usedPairKeys[pk1] ? 1 : 0) + (usedPairKeys[pk2] ? 1 : 0);
    var delta = Math.abs(_teamRating(s.t1) - _teamRating(s.t2));
    var oppVar = GlobalTracker.score(s.t1[0].id, s.t1[1].id, s.t2[0].id, s.t2[1].id);
    var isBetter = false;
    if (rep < bestRep) isBetter = true;
    else if (rep === bestRep && delta < bestDelta) isBetter = true;
    else if (rep === bestRep && delta === bestDelta && oppVar < bestOppVar) isBetter = true;
    if (isBetter) {
      best = s; bestRep = rep; bestDelta = delta; bestOppVar = oppVar;
    }
  }
  return best;
}

// ============================================================
// Build Phase 2 rounds  MinDelta 2-Court Engine
// Architecture:
//   1. Pick who rests (equity + rating-weighted for outliers)
//   2. Run FULL MinDelta (_findBestRound) on all 8 playing players
//   3. Assign court labels: higher avg-rating court = Oro, lower = Plata
// 
// This naturally separates tiers (good with good, weak with weak)
// while maintaining optimal delta balance and pair variety.
// Much better than rigid tier-locking because the 4th/5th boundary
// can flex, avoiding forced pair repeats with only 4 players.
// ============================================================
function buildPhase2Matches(cfg, players, numCourts, dayRanking, p1Counts, p1RoundCount) {
  if (!cfg || !players.length || !dayRanking.length) return { rounds: [], counts: {} };
  var N = players.length;
  var S = numCourts * 4;
  var p2Count = cfg.rounds - p1RoundCount;
  if (p2Count <= 0) return { rounds: [], counts: {} };
  var dayRankMap = {};
  dayRanking.forEach(function(s) { dayRankMap[s.id] = s.dayRank; });
  var sorted = players.slice().sort(function(a, b) { return (dayRankMap[a.id] || 99) - (dayRankMap[b.id] || 99); });
  var counts = {};
  sorted.forEach(function(p) { counts[p.id] = p1Counts[p.id] || 0; });
  var rounds = [];
  var tierNames = ["Oro", "Plata", "Bronce", "Hierro", "Madera"];
  // Track used pairs and matchups for Phase 2 (separate from Phase 1)
  var usedPairKeysP2 = {};
  var usedMatchupsP2 = {};

  for (var r = 0; r < p2Count; r++) {
    var roundNum = p1RoundCount + r + 1;

    // === STEP 1: Pick who rests ===
    // Priority: most-played rests first; on tie, lowest-rated rests first
    var resting = [];
    if (N > S) {
      var restCount = N - S;
      var priority = sorted.slice().sort(function(a, b) {
        if (counts[a.id] !== counts[b.id]) return counts[b.id] - counts[a.id];
        return (dayRankMap[b.id] || 99) - (dayRankMap[a.id] || 99);
      });
      resting = priority.slice(0, restCount);
    }
    var restIds = {};
    resting.forEach(function(p) { restIds[p.id] = true; });
    var playing = sorted.filter(function(p) { return !restIds[p.id]; });
    playing.forEach(function(p) { counts[p.id]++; });

    // === STEP 2: Sort playing by rating for consistent input ===
    var ps = playing.slice().sort(function(a, b) {
      return (dayRankMap[a.id] || 99) - (dayRankMap[b.id] || 99);
    });
    var nc = Math.min(numCourts, Math.floor(ps.length / 4));

    // === STEP 3: Assign courts ===
    // Phase 2 uses TIERED assignment: players sorted by dayRank go in blocks of 4
    // Top 4  Oro, next 4  Plata, next 4  Bronce, etc.
    var courtConfigs;
    if (nc >= 2 && ps.length >= 8) {
      if (nc >= 3) {
        // 3+ courts: Block partition (tiered)  keeps same-level players together
        courtConfigs = [];
        for (var bi = 0; bi < nc; bi++) {
          var block = ps.slice(bi * 4, (bi + 1) * 4);
          if (block.length < 4) break;
          // Generate all 3 possible splits
          var splits = [
            { t1: [block[0], block[1]], t2: [block[2], block[3]] },
            { t1: [block[0], block[2]], t2: [block[1], block[3]] },
            { t1: [block[0], block[3]], t2: [block[1], block[2]] }
          ];
          // Score each split: prefer unused matchups, then unused pairs, then min delta
          var bestSp = null, bestSpScore = Infinity;
          for (var spi = 0; spi < splits.length; spi++) {
            var sp = splits[spi];
            var r1 = _teamRating(sp.t1), r2 = _teamRating(sp.t2);
            var delta = Math.abs(r1 - r2);
            // Matchup key: full 4-player configuration (order-independent)
            var ids = [sp.t1[0].id, sp.t1[1].id, sp.t2[0].id, sp.t2[1].id].sort();
            var mk = _pairSortKey(sp.t1[0], sp.t1[1]) + "v" + _pairSortKey(sp.t2[0], sp.t2[1]);
            var matchupUses = usedMatchupsP2[mk] || 0;
            // Pair keys
            var pk1 = _pairSortKey(sp.t1[0], sp.t1[1]);
            var pk2 = _pairSortKey(sp.t2[0], sp.t2[1]);
            var pairUses = (usedPairKeysP2[pk1] || 0) + (usedPairKeysP2[pk2] || 0);
            // Priority: matchup repeats (x10000) > pair repeats (x100) > delta
            var score = matchupUses * 10000 + pairUses * 100 + delta;
            if (score < bestSpScore) { bestSpScore = score; bestSp = sp; bestSp.delta = delta; }
          }
          if (bestSp) courtConfigs.push({ t1: bestSp.t1, t2: bestSp.t2, delta: bestSp.delta });
        }
        if (courtConfigs.length < nc) courtConfigs = null;
      } else {
        // 2 courts: use full _findBestRound (exhaustive, fast)
        courtConfigs = _findBestRound(ps, usedPairKeysP2, nc);
      }
    } else if (nc === 1 && ps.length >= 4) {
      // Single court: use _findBestSplit4
      var split = _findBestSplit4(ps.slice(0, 4), usedPairKeysP2);
      if (split) {
        var d = Math.abs(_teamRating(split.t1) - _teamRating(split.t2));
        courtConfigs = [{ t1: split.t1, t2: split.t2, delta: d }];
      }
    }

    // === STEP 4: Assign tier labels (higher avg rating = Oro) ===
    var courtList = [];
    if (courtConfigs && courtConfigs.length >= nc) {
      // Calculate avg rating per court to assign tier labels
      var courtRatings = [];
      for (var ci = 0; ci < nc; ci++) {
        var cc = courtConfigs[ci];
        var avgR = (_teamRating(cc.t1) + _teamRating(cc.t2)) / 4;
        courtRatings.push({ idx: ci, avgR: avgR });
      }
      // Sort by avg rating descending  highest gets Oro
      courtRatings.sort(function(a, b) { return b.avgR - a.avgR; });

      for (var li = 0; li < courtRatings.length; li++) {
        var cIdx = courtRatings[li].idx;
        var cc2 = courtConfigs[cIdx];
        var tierLabel = tierNames[li] || ("Pista " + (li + 1));
        // Record pairs (as counters) and matchups
        var pk1 = _pairSortKey(cc2.t1[0], cc2.t1[1]);
        var pk2 = _pairSortKey(cc2.t2[0], cc2.t2[1]);
        usedPairKeysP2[pk1] = (usedPairKeysP2[pk1] || 0) + 1;
        usedPairKeysP2[pk2] = (usedPairKeysP2[pk2] || 0) + 1;
        var mk = pk1 + "v" + pk2;
        usedMatchupsP2[mk] = (usedMatchupsP2[mk] || 0) + 1;
        GlobalTracker.record(cc2.t1[0].id, cc2.t1[1].id, cc2.t2[0].id, cc2.t2[1].id);
        courtList.push({
          court: li + 1,
          t1: cc2.t1,
          t2: cc2.t2,
          tier: tierLabel,
          phase: 2
        });
      }
    } else {
      // Fallback: simple split
      for (var fb = 0; fb < nc; fb++) {
        var bi = fb * 4;
        courtList.push({
          court: fb + 1,
          t1: [ps[bi], ps[bi + 3]],
          t2: [ps[bi + 1], ps[bi + 2]],
          tier: tierNames[fb] || ("Pista " + (fb + 1)),
          phase: 2
        });
      }
    }

    rounds.push({
      round: roundNum,
      phase: 2,
      phaseLabel: "King of the Court",
      courts: courtList,
      resting: resting,
      playing: playing
    });
  }
  return { rounds: rounds, counts: counts };
}


function computeSession(totalTime, selPlayers, numCourts) {
  var N = selPlayers.length;
  if (N < 4 || numCourts < 1 || totalTime < 6) return { error: "Minimo: 4 jugadores, 1 pista, 6 min" };
  var cfg = findOptimal(totalTime, N, numCourts);
  if (!cfg) return { error: "Sin configuracion viable" };
  var ext = findExtension(totalTime, N, numCourts, cfg);
  var p1Rounds = Math.ceil(cfg.rounds * 0.5);
  var p2Rounds = cfg.rounds - p1Rounds;

  // === Phase 2 matchup cap ===
  // With 4 players per court (block partition), only 3 unique splits exist.
  // If no one rests in Phase 2 (N <= numCourts*4), cap p2 at 3 rounds
  // and redistribute extra time by increasing game duration.
  var S = numCourts * 4;
  var maxP2Splits = 3; // always 3 unique ways to split 4 players into 2v2
  if (N <= S && p2Rounds > maxP2Splits) {
    var excessRounds = p2Rounds - maxP2Splits;
    p2Rounds = maxP2Splits;
    // Total rounds reduced
    var newTotalRounds = p1Rounds + p2Rounds;
    // Recalculate duration to fill the same total time
    var totalSec = totalTime * 60;
    var newDurationSec = Math.floor(totalSec / newTotalRounds);
    // Clamp to reasonable max (allow stretching beyond QW.max for this case)
    var maxDurationSec = Math.max(QW.max * 60, 15 * 60); // up to 15 min
    if (newDurationSec > maxDurationSec) newDurationSec = maxDurationSec;
    var newUsedSec = newTotalRounds * newDurationSec;
    var newDeadSec = totalSec - newUsedSec;
    // Update cfg with new values
    cfg = Object.assign({}, cfg, {
      rounds: newTotalRounds,
      duration: Math.round(newDurationSec / 60 * 100) / 100,
      durationSec: newDurationSec,
      usedTime: Math.round(newUsedSec / 60 * 100) / 100,
      usedTimeSec: newUsedSec,
      deadTime: Math.round(newDeadSec / 60 * 100) / 100,
      deadTimeSec: newDeadSec,
      p2Capped: true
    });
  }

  // Only build Phase 1 at creation time
  var p1Matches = buildPhase1Matches(cfg, selPlayers, numCourts);
  return { cfg: cfg, ext: ext, p1Matches: p1Matches, p2Matches: null, p1Rounds: p1Rounds, p2Rounds: p2Rounds, N: N, phase2Generated: false };
}

// ============================================================
// DESIGN TOKENS
// ============================================================
var C = { bg: "#05080f", s1: "#0a1022", s2: "#0f1730", s3: "#152042", bd: "#1a2a50", cy: "#00e5ff", gl: "#ffc400", si: "#78909c", bz: "#e65100", gn: "#00e676", rd: "#ff1744", or: "#ff9100", tx: "#eceff1", tm: "#7986cb", td: "#3949ab", wh: "#fff" };
var F = { d: "'Sora', system-ui", m: "'JetBrains Mono', monospace", b: "'DM Sans', system-ui" };

var h = React.createElement;

function Avatar(props) {
  var nickname = props.nickname, size = props.size || 30, sx = props.style || {};
  var src = AVATARS[nickname];
  if (!src) return h("div", { style: Object.assign({ width: size, height: size, borderRadius: "50%", background: C.s3, display: "flex", alignItems: "center", justifyContent: "center", fontSize: size * 0.4, color: C.tm, fontWeight: 700, fontFamily: F.m, flexShrink: 0 }, sx) }, (nickname && nickname[0]) || "?");
  return h("img", { src: src, alt: nickname, style: Object.assign({ width: size, height: size, borderRadius: "50%", objectFit: "cover", flexShrink: 0, border: "2px solid " + C.bd }, sx) });
}

function Box(props) {
  var accent = props.accent, glow = props.glow;
  return h("div", { onClick: props.onClick, style: Object.assign({ background: C.s2, borderRadius: 14, padding: 22, border: "1px solid " + (accent ? accent + "35" : C.bd), boxShadow: glow ? "0 0 50px " + (accent || C.cy) + "12" : "0 2px 12px #0006", transition: "all .3s" }, props.style || {}) }, props.children);
}

function Label(props) {
  return h("div", { style: { display: "flex", alignItems: "center", gap: 7, marginBottom: 14 } },
    props.icon && h("span", { style: { fontSize: 13 } }, props.icon),
    h("span", { style: { fontSize: 11, fontFamily: F.m, color: props.color || C.cy, letterSpacing: 2.5, textTransform: "uppercase", fontWeight: 700 } }, props.text)
  );
}

function Tag(props) {
  var sm = props.sm;
  return h("span", { style: { display: "inline-flex", padding: sm ? "2px 7px" : "3px 10px", borderRadius: 16, fontSize: sm ? 10 : 11, fontWeight: 700, background: props.color + "14", color: props.color, border: "1px solid " + props.color + "30", fontFamily: F.m, textTransform: "uppercase", letterSpacing: .4, whiteSpace: "nowrap" } }, props.text);
}

function Num(props) {
  return h("div", { style: { textAlign: "center", flex: 1, minWidth: props.sm ? 60 : 80 } },
    h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1.5, marginBottom: 3 } }, props.label),
    h("div", { style: { fontSize: props.sm ? 20 : 28, fontWeight: 800, color: props.color || C.cy, fontFamily: F.d, lineHeight: 1 } }, props.value)
  );
}

function TabBar(props) {
  return h("div", { style: { display: "flex", gap: 3, background: C.s1, borderRadius: 10, padding: 3, marginBottom: 22 } },
    props.tabs.map(function(t) {
      return h("button", { key: t.id, onClick: function() { props.onChange(t.id); }, style: { flex: 1, padding: "9px 6px", border: "none", borderRadius: 7, cursor: "pointer", background: props.active === t.id ? C.s3 : "transparent", color: props.active === t.id ? C.cy : C.td, fontSize: 11, fontFamily: F.m, fontWeight: 600, letterSpacing: .5, transition: "all .2s", textTransform: "uppercase", boxShadow: props.active === t.id ? "0 2px 8px #0005" : "none" } }, t.icon + " " + t.label);
    })
  );
}

// ============================================================
// REALTIME STATUS INDICATOR
// ============================================================
function RealtimeIndicator(props) {
  var status = props.status;
  var colors = { connected: C.gn, connecting: C.gl, error: C.rd, disconnected: C.td };
  var labels = { connected: "En vivo", connecting: "Conectando...", error: "Sin conexin", disconnected: "Desconectado" };
  var dotColor = colors[status] || C.td;
  var label = labels[status] || status;
  return h("div", { style: { display: "flex", alignItems: "center", gap: 5, padding: "4px 10px", background: dotColor + "12", borderRadius: 20, border: "1px solid " + dotColor + "30" } },
    h("div", { style: { width: 7, height: 7, borderRadius: "50%", background: dotColor, boxShadow: status === "connected" ? "0 0 6px " + dotColor : "none", animation: status === "connecting" ? "timerPulse 1s infinite alternate" : "none" } }),
    h("span", { style: { fontSize: 10, fontFamily: F.m, color: dotColor, fontWeight: 600, letterSpacing: .5, textTransform: "uppercase" } }, label)
  );
}

function Btn(props) {
  return h("button", { onClick: props.onClick, disabled: props.disabled, style: Object.assign({ padding: "10px 20px", border: "none", borderRadius: 9, cursor: props.disabled ? "not-allowed" : "pointer", background: props.disabled ? C.bd : (props.color || C.cy), color: props.disabled ? C.td : C.bg, fontSize: 12, fontWeight: 700, fontFamily: F.d, opacity: props.disabled ? 0.5 : 1, transition: "all .2s" }, props.style || {}) }, props.children);
}

// ============================================================
// ROSTER COMPONENT
// ============================================================
function Roster(props) {
  var players = props.players, onToggle = props.onToggle, onRank = props.onRank, onAdd = props.onAdd, onDelete = props.onDelete;
  var active = players.filter(function(p) { return p.active; }).length;
  // Add player form state
  var showAddState = React.useState(false);
  var showAdd = showAddState[0], setShowAdd = showAddState[1];
  var newNameState = React.useState("");
  var newName = newNameState[0], setNewName = newNameState[1];
  var newPhoneState = React.useState("");
  var newPhone = newPhoneState[0], setNewPhone = newPhoneState[1];
  var newAvatarState = React.useState(null);
  var newAvatar = newAvatarState[0], setNewAvatar = newAvatarState[1];
  var fileInputRef = React.useRef(null);
  // Delete confirmation state
  var confirmDelState = React.useState(null);
  var confirmDel = confirmDelState[0], setConfirmDel = confirmDelState[1];

  var handleAvatarFile = function(e) {
    var file = e.target.files && e.target.files[0];
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function(ev) {
      var img = new Image();
      img.onload = function() {
        var canvas = document.createElement("canvas");
        canvas.width = 48; canvas.height = 48;
        var ctx = canvas.getContext("2d");
        // Center crop
        var s = Math.min(img.width, img.height);
        var sx = (img.width - s) / 2, sy = (img.height - s) / 2;
        ctx.drawImage(img, sx, sy, s, s, 0, 0, 48, 48);
        setNewAvatar(canvas.toDataURL("image/jpeg", 0.7));
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  };

  var handleAdd = function() {
    var name = newName.trim();
    if (!name) return;
    onAdd(name, newPhone.trim(), newAvatar);
    setNewName(""); setNewPhone(""); setNewAvatar(null); setShowAdd(false);
  };

  return h("div", null,
    h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 14 } },
      h(Label, { icon: "\ud83d\udc65", text: "Roster de Jugadores" }),
      h("div", { style: { display: "flex", gap: 6, alignItems: "center" } },
        h(Tag, { text: active + " activos", color: C.gn }),
        h("button", { onClick: function() { setShowAdd(!showAdd); }, style: { padding: "4px 10px", border: "1.5px solid " + C.cy + "60", borderRadius: 6, background: showAdd ? C.cy + "15" : "transparent", color: C.cy, cursor: "pointer", fontSize: 10, fontWeight: 700, fontFamily: F.m } }, showAdd ? "\u2715 Cerrar" : "\u2795 Nuevo")
      )
    ),
    // Add player form
    showAdd && h("div", { style: { padding: "12px", background: C.cy + "08", borderRadius: 9, border: "1.5px solid " + C.cy + "30", marginBottom: 10 } },
      h("div", { style: { display: "flex", gap: 10, alignItems: "center" } },
        // Avatar upload circle
        h("div", { onClick: function() { fileInputRef.current && fileInputRef.current.click(); }, style: { width: 48, height: 48, borderRadius: "50%", background: newAvatar ? "none" : C.s3, border: "2px dashed " + (newAvatar ? C.gn : C.cy + "60"), cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", overflow: "hidden", flexShrink: 0, transition: "all .2s" } },
          newAvatar ? h("img", { src: newAvatar, style: { width: 48, height: 48, borderRadius: "50%", objectFit: "cover" } })
            : h("div", { style: { textAlign: "center" } }, h("div", { style: { fontSize: 16 } }, "\ud83d\udcf7"), h("div", { style: { fontSize: 7, color: C.td, fontFamily: F.m } }, "Foto"))
        ),
        h("input", { ref: fileInputRef, type: "file", accept: "image/*", onChange: handleAvatarFile, style: { display: "none" } }),
        // Fields
        h("div", { style: { flex: 1, display: "flex", flexDirection: "column", gap: 6 } },
          h("input", { type: "text", placeholder: "Nickname", value: newName, onChange: function(e) { setNewName(e.target.value); }, onKeyDown: function(e) { if (e.key === "Enter") handleAdd(); }, style: { padding: "7px 10px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.tx, fontFamily: F.m, fontSize: 12 } }),
          h("div", { style: { display: "flex", gap: 6 } },
            h("input", { type: "tel", placeholder: "Telefono (opcional)", value: newPhone, onChange: function(e) { setNewPhone(e.target.value); }, onKeyDown: function(e) { if (e.key === "Enter") handleAdd(); }, style: { flex: 1, padding: "7px 10px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.tx, fontFamily: F.m, fontSize: 12, minWidth: 0 } }),
            h("button", { onClick: handleAdd, style: { padding: "7px 14px", border: "none", borderRadius: 6, background: C.cy, color: C.bg, cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m, flexShrink: 0 } }, "\u2713 Agregar")
          )
        )
      )
    ),
    h("div", { style: { display: "grid", gap: 5 } },
      players.slice().sort(function(a, b) { return a.ranking - b.ranking; }).map(function(p) {
        var s = p.stats || {};
        var rc = s.rating > 60 ? C.gn : s.rating > 40 ? C.cy : s.rating > 20 ? C.gl : s.rating > 0 ? C.or : C.td;
        return h("div", { key: p.id },
          h("div", { style: { display: "flex", alignItems: "center", gap: 10, padding: "9px 12px", background: p.active ? C.s3 : C.rd + "08", borderRadius: confirmDel === p.id ? "9px 9px 0 0" : 9, border: "1px solid " + (p.active ? C.bd : C.rd + "20"), opacity: p.active ? 1 : .45 } },
            h("div", { style: { position: "relative" } },
              h(Avatar, { nickname: p.nickname, size: 34 }),
              h("div", { style: { position: "absolute", bottom: -3, right: -3, width: 20, height: 20, borderRadius: "50%", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 10, fontWeight: 800, fontFamily: F.m, background: p.ranking <= 3 ? C.gl : p.ranking <= 8 ? C.cy : C.s1, color: p.ranking <= 8 ? C.bg : C.tm, border: "1.5px solid " + C.bg } }, p.ranking)
            ),
            h("div", { style: { flex: 1, minWidth: 0 } },
              h("div", { style: { fontSize: 13, fontWeight: 700, color: C.tx, fontFamily: F.d, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" } }, p.nickname),
              h("div", { style: { display: "flex", gap: 6, alignItems: "center", marginTop: 1 } },
                h("span", { style: { fontSize: 9, color: rc, fontFamily: F.m, fontWeight: 700 } }, s.rating ? s.rating.toFixed(1) : "\u2014"),
                s.played > 0 && h("span", { style: { fontSize: 10, color: s.winRate >= 50 ? C.gn : C.or, fontFamily: F.m } }, s.winRate + "% W"),
                s.played > 0 && h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, s.wins + "/" + s.played)
              )
            ),
            !p.phone && h(Tag, { text: "Inv", color: C.or, sm: true }),
            h("div", { style: { display: "flex", gap: 3 } },
              h("button", { onClick: function() { onRank(p.id, -1); }, style: { width: 22, height: 22, border: "1px solid " + C.bd, borderRadius: 5, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 10, display: "flex", alignItems: "center", justifyContent: "center" } }, "\u25b2"),
              h("button", { onClick: function() { onRank(p.id, 1); }, style: { width: 22, height: 22, border: "1px solid " + C.bd, borderRadius: 5, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 10, display: "flex", alignItems: "center", justifyContent: "center" } }, "\u25bc")
            ),
            h("button", { onClick: function() { onToggle(p.id); }, style: { padding: "3px 8px", border: "none", borderRadius: 5, cursor: "pointer", background: p.active ? C.rd + "18" : C.gn + "18", color: p.active ? C.rd : C.gn, fontSize: 9, fontFamily: F.m, fontWeight: 700 } }, p.active ? "\u2715" : "\u2713"),
            h("button", { onClick: function() { setConfirmDel(confirmDel === p.id ? null : p.id); }, style: { width: 22, height: 22, border: "none", borderRadius: 5, background: "transparent", color: C.rd, cursor: "pointer", fontSize: 11, display: "flex", alignItems: "center", justifyContent: "center", opacity: 0.35 } }, "\ud83d\uddd1\ufe0f")
          ),
          // Delete confirmation
          confirmDel === p.id && h("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", padding: "7px 12px", background: C.rd + "0c", borderRadius: "0 0 9px 9px", border: "1px solid " + C.rd + "25", borderTop: "none" } },
            h("span", { style: { fontSize: 10, color: C.rd, fontFamily: F.m, fontWeight: 600 } }, "\u26a0\ufe0f Eliminar a " + p.nickname + "?"),
            h("div", { style: { display: "flex", gap: 6 } },
              h("button", { onClick: function() { setConfirmDel(null); onDelete(p.id); }, style: { padding: "4px 12px", border: "none", borderRadius: 5, background: C.rd, color: "#fff", cursor: "pointer", fontSize: 10, fontWeight: 700, fontFamily: F.m } }, "\u2713 Eliminar"),
              h("button", { onClick: function() { setConfirmDel(null); }, style: { padding: "4px 12px", border: "1px solid " + C.bd, borderRadius: 5, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 10, fontFamily: F.m } }, "Cancelar")
            )
          )
        );
      })
    )
  );
}

// ============================================================
// CREATE SESSION
// ============================================================
function CreateSession(props) {
  var players = props.players, onCreateSession = props.onCreateSession;
  var now = new Date();
  var pad = function(n) { return String(n).padStart(2, "0"); };
  var dateState = React.useState(now.getFullYear() + "-" + pad(now.getMonth() + 1) + "-" + pad(now.getDate()));
  var date = dateState[0], setDate = dateState[1];
  var hourState = React.useState(pad(now.getHours()));
  var hour = hourState[0], setHour = hourState[1];
  var minuteState = React.useState(pad(Math.ceil(now.getMinutes() / 15) * 15 % 60));
  var minute = minuteState[0], setMinute = minuteState[1];
  var ttState = React.useState(60);
  var totalTime = ttState[0], setTotalTime = ttState[1];
  var ncState = React.useState(function() {
    var initN = players.filter(function(p) { return p.active && p.phone; }).length;
    return initN <= 7 ? 1 : Math.floor(initN / 4);
  });
  var numCourts = ncState[0], setNumCourts = ncState[1];

  // Game duration range state
  var gmMinState = React.useState(QW.min);
  var gameMin = gmMinState[0], setGameMin = gmMinState[1];
  var gmMaxState = React.useState(QW.max);
  var gameMax = gmMaxState[0], setGameMax = gmMaxState[1];
  // Sync QW global with state
  React.useEffect(function() {
    QW.min = gameMin; QW.max = gameMax;
  }, [gameMin, gameMax]);

  var selState = React.useState(function() {
    var obj = {};
    players.filter(function(p) { return p.active && p.phone; }).forEach(function(p) { obj[p.id] = true; });
    return obj;
  });
  var selected = selState[0], setSelected = selState[1];

  var togglePlayer = function(id) {
    setSelected(function(prev) { var next = Object.assign({}, prev); if (next[id]) { delete next[id]; } else { next[id] = true; } return next; });
  };
  var selectAll = function() {
    var obj = {};
    players.filter(function(p) { return p.active; }).forEach(function(p) { obj[p.id] = true; });
    guests.forEach(function(g) { obj[g.id] = true; });
    setSelected(obj);
  };
  var selectNone = function() { setSelected({}); };

  // Guest (invitado) system
  var guestState = React.useState([]);
  var guests = guestState[0], setGuests = guestState[1];
  var guestIdCounter = React.useRef(-1);
  var guestNameState = React.useState("");
  var guestName = guestNameState[0], setGuestName = guestNameState[1];
  var guestRatingState = React.useState("50");
  var guestRating = guestRatingState[0], setGuestRating = guestRatingState[1];
  var guestShowState = React.useState(false);
  var guestShow = guestShowState[0], setGuestShow = guestShowState[1];

  var addGuest = function() {
    var name = guestName.trim();
    if (!name) return;
    var rating = Math.max(1, Math.min(100, parseInt(guestRating) || 50));
    var id = guestIdCounter.current--;
    var g = { id: id, name: name, nickname: name, phone: "", ranking: 99, active: true, isGuest: true, avatarUrl: null, stats: { played: 0, wins: 0, winRate: 0, diff: 0, rating: rating } };
    setGuests(function(prev) { return prev.concat([g]); });
    setSelected(function(prev) { var next = Object.assign({}, prev); next[id] = true; return next; });
    setGuestName(""); setGuestRating("50"); setGuestShow(false);
  };
  var removeGuest = function(id) {
    setGuests(function(prev) { return prev.filter(function(g) { return g.id !== id; }); });
    setSelected(function(prev) { var next = Object.assign({}, prev); delete next[id]; return next; });
  };

  var allPlayers = players.concat(guests);
  var selectedPlayers = allPlayers.filter(function(p) { return selected[p.id]; }).sort(function(a, b) { return a.ranking - b.ranking; });
  var N = selectedPlayers.length;
  var maxCourts = Math.floor(N / 4);

  // Auto-set courts when player count changes: 0-7->1, 8-11->2, 12-15->3, 16-19->4, 20-23->5...
  var prevNRef = React.useRef(N);
  React.useEffect(function() {
    if (N !== prevNRef.current) {
      prevNRef.current = N;
      var auto = N <= 7 ? 1 : Math.floor(N / 4);
      var mc = Math.floor(N / 4);
      if (mc > 0 && auto > mc) auto = mc;
      if (auto < 1) auto = 1;
      setNumCourts(auto);
    }
  }, [N]);

  var preview = React.useMemo(function() {
    if (N < 4) return null;
    var eff = Math.min(numCourts, maxCourts);
    return computeSession(totalTime, selectedPlayers, eff);
  }, [JSON.stringify(Object.keys(selected).sort()), numCourts, totalTime, maxCourts, gameMin, gameMax]);

  var canCreate = N >= 4 && numCourts >= 1 && totalTime >= 6 && preview && !preview.error;

  var handleCreate = function() {
    if (!canCreate) return;
    var eff = Math.min(numCourts, maxCourts);
    onCreateSession({ date: date, time: hour + ":" + minute, totalTime: totalTime, numCourts: eff, players: selectedPlayers, result: computeSession(totalTime, selectedPlayers, eff) });
  };

  return h("div", null,
    // Config box
    h(Box, { style: { marginBottom: 16 } },
      h(Label, { icon: "\ud83d\udcc5", text: "Configuracion de Partida" }),
      h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))", gap: 14 } },
        // Date
        h("div", null,
          h("div", { style: { fontSize: 11, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, "Fecha"),
          h("input", { type: "date", value: date, onChange: function(e) { setDate(e.target.value); }, style: { width: "100%", padding: "8px 10px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 7, color: C.tx, fontFamily: F.m, fontSize: 13 } })
        ),
        // Time
        h("div", null,
          h("div", { style: { fontSize: 11, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, "Hora"),
          h("div", { style: { display: "flex", gap: 6 } },
            h("select", { value: hour, onChange: function(e) { setHour(e.target.value); }, style: { flex: 1, padding: "8px 6px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 7, color: C.tx, fontFamily: F.m, fontSize: 13 } },
              Array.from({ length: 24 }, function(_, i) { return h("option", { key: i, value: pad(i) }, pad(i)); })
            ),
            h("span", { style: { color: C.td, fontSize: 20, lineHeight: "38px" } }, ":"),
            h("select", { value: minute, onChange: function(e) { setMinute(e.target.value); }, style: { flex: 1, padding: "8px 6px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 7, color: C.tx, fontFamily: F.m, fontSize: 13 } },
              ["00", "15", "30", "45"].map(function(m) { return h("option", { key: m, value: m }, m); })
            )
          )
        ),
        // Duration
        h("div", null,
          h("div", { style: { fontSize: 11, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, "Duracion total"),
          h("div", { style: { display: "flex", alignItems: "center", gap: 6 } },
            [60, 75, 90, 120].map(function(t) { return h("button", { key: t, onClick: function() { setTotalTime(t); }, style: { flex: 1, padding: "8px 4px", border: "1px solid " + (totalTime === t ? C.cy : C.bd), borderRadius: 7, background: totalTime === t ? C.cy + "18" : C.s1, color: totalTime === t ? C.cy : C.tm, cursor: "pointer", fontSize: 12, fontWeight: 700, fontFamily: F.m } }, t + "'"); })
          ),
          h("div", { style: { display: "flex", alignItems: "center", gap: 6, marginTop: 6 } },
            h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "Custom:"),
            h("input", { type: "number", min: 6, max: 240, value: totalTime, onChange: function(e) { var v = parseInt(e.target.value); if (!isNaN(v) && v >= 6) setTotalTime(v); }, style: { width: 60, padding: "5px 6px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.cy, fontFamily: F.m, fontSize: 12, fontWeight: 700, textAlign: "center" } }),
            h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "min")
          )
        ),
        // Courts
        h("div", null,
          h("div", { style: { fontSize: 11, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, "Pistas"),
          h("div", { style: { display: "flex", alignItems: "center", gap: 6 } },
            (function() {
              var courtOptions = [];
              var limit = Math.max(maxCourts, 1);
              for (var c = 1; c <= limit; c++) courtOptions.push(c);
              return courtOptions.map(function(c) { return h("button", { key: c, onClick: function() { setNumCourts(c); }, style: { flex: 1, padding: "8px 4px", border: "1px solid " + (numCourts === c ? C.gl : C.bd), borderRadius: 7, background: numCourts === c ? C.gl + "18" : C.s1, color: numCourts === c ? C.gl : C.tm, cursor: "pointer", fontSize: 14, fontWeight: 700, fontFamily: F.m } }, c); });
            })()
          ),
          maxCourts > 0 && h("div", { style: { fontSize: 10, color: C.td, marginTop: 4, fontFamily: F.m } }, "Max " + maxCourts + " pistas con " + N + " jugadores")
        ),
        // Game duration range
        h("div", { style: { gridColumn: "1 / -1" } },
          h("div", { style: { fontSize: 11, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, "\u23f1 Rango de Juego (min por juego)"),
          h("div", { style: { display: "flex", alignItems: "center", gap: 8 } },
            h("div", { style: { display: "flex", alignItems: "center", gap: 4 } },
              h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "Min:"),
              h("select", { value: gameMin, onChange: function(e) { var v = parseInt(e.target.value); if (v <= gameMax) setGameMin(v); }, style: { padding: "6px 8px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.cy, fontFamily: F.m, fontSize: 12, fontWeight: 700 } },
                [5, 6, 7, 8, 9, 10].map(function(v) { return h("option", { key: v, value: v }, v + "'"); })
              )
            ),
            h("span", { style: { color: C.td, fontSize: 14 } }, "\u2014"),
            h("div", { style: { display: "flex", alignItems: "center", gap: 4 } },
              h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "Max:"),
              h("select", { value: gameMax, onChange: function(e) { var v = parseInt(e.target.value); if (v >= gameMin) setGameMax(v); }, style: { padding: "6px 8px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.cy, fontFamily: F.m, fontSize: 12, fontWeight: 700 } },
                [8, 9, 10, 11, 12, 14, 15].map(function(v) { return h("option", { key: v, value: v }, v + "'"); })
              )
            ),
            h("div", { style: { display: "flex", gap: 4, marginLeft: 4 } },
              [{ label: "6-12", min: 6, max: 12 }, { label: "8-12", min: 8, max: 12 }, { label: "10-12", min: 10, max: 12 }].map(function(preset) {
                var active = gameMin === preset.min && gameMax === preset.max;
                return h("button", { key: preset.label, onClick: function() { setGameMin(preset.min); setGameMax(preset.max); }, style: { padding: "5px 8px", border: "1px solid " + (active ? C.or : C.bd), borderRadius: 6, background: active ? C.or + "18" : C.s1, color: active ? C.or : C.tm, cursor: "pointer", fontSize: 10, fontWeight: 700, fontFamily: F.m } }, preset.label);
              })
            )
          ),
          h("div", { style: { fontSize: 9, color: C.td, marginTop: 4, fontFamily: F.m } }, "Cada juego durara entre " + gameMin + " y " + gameMax + " minutos")
        )
      )
    ),
    // Player selection
    h(Box, { style: { marginBottom: 16 } },
      h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10 } },
        h(Label, { icon: "\ud83c\udfaf", text: "Seleccionar Jugadores" }),
        h("div", { style: { display: "flex", gap: 6 } },
          h(Tag, { text: N + " seleccionados", color: N >= 4 ? C.gn : C.rd }),
          h("button", { onClick: selectAll, style: { padding: "3px 8px", border: "1px solid " + C.bd, borderRadius: 5, background: "transparent", color: C.cy, cursor: "pointer", fontSize: 10, fontFamily: F.m } }, "Todos"),
          h("button", { onClick: selectNone, style: { padding: "3px 8px", border: "1px solid " + C.bd, borderRadius: 5, background: "transparent", color: C.rd, cursor: "pointer", fontSize: 10, fontFamily: F.m } }, "Ninguno")
        )
      ),
      h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(130px, 1fr))", gap: 6 } },
        players.slice().sort(function(a, b) { return a.ranking - b.ranking; }).map(function(p) {
          var sel = !!selected[p.id];
          var s = p.stats || {};
          return h("div", { key: p.id, onClick: function() { togglePlayer(p.id); }, style: { display: "flex", alignItems: "center", gap: 8, padding: "8px 10px", background: sel ? C.cy + "10" : C.s1, borderRadius: 9, border: "1.5px solid " + (sel ? C.cy + "60" : C.bd), cursor: "pointer", transition: "all .15s", opacity: sel ? 1 : .5 } },
            h(Avatar, { nickname: p.nickname, size: 28 }),
            h("div", { style: { flex: 1, minWidth: 0 } },
              h("div", { style: { fontSize: 12, fontWeight: 700, color: sel ? C.tx : C.tm, fontFamily: F.d, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" } }, p.nickname),
              h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, (s.rating ? s.rating.toFixed(0) : "\u2014") + " pts \u00b7 #" + p.ranking)
            ),
            h("div", { style: { width: 18, height: 18, borderRadius: 4, border: "2px solid " + (sel ? C.cy : C.bd), background: sel ? C.cy : "transparent", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 10, color: C.bg, fontWeight: 800, flexShrink: 0 } }, sel ? "\u2713" : "")
          );
        }),
        // Guest cards
        guests.map(function(g) {
          var sel = !!selected[g.id];
          return h("div", { key: g.id, onClick: function() { togglePlayer(g.id); }, style: { display: "flex", alignItems: "center", gap: 8, padding: "8px 10px", background: sel ? "#ff990015" : C.s1, borderRadius: 9, border: "1.5px solid " + (sel ? "#ff9900" + "80" : C.bd), cursor: "pointer", transition: "all .15s", opacity: sel ? 1 : .6 } },
            h("div", { style: { width: 28, height: 28, borderRadius: "50%", background: "linear-gradient(135deg, #ff9900, #ff6600)", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 13, color: "#fff", fontWeight: 800, flexShrink: 0 } }, g.nickname.charAt(0).toUpperCase()),
            h("div", { style: { flex: 1, minWidth: 0 } },
              h("div", { style: { fontSize: 12, fontWeight: 700, color: sel ? C.tx : C.tm, fontFamily: F.d, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" } }, g.nickname),
              h("div", { style: { fontSize: 10, color: "#ff9900", fontFamily: F.m } }, g.stats.rating + " pts \u00b7 Invitado")
            ),
            h("button", { onClick: function(e) { e.stopPropagation(); removeGuest(g.id); }, style: { width: 18, height: 18, borderRadius: 4, border: "none", background: C.rd + "30", color: C.rd, cursor: "pointer", fontSize: 10, display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0 } }, "\u2715")
          );
        })
      ),
      // Add Guest section
      h("div", { style: { marginTop: 10 } },
        !guestShow
          ? h("button", { onClick: function() { setGuestShow(true); }, style: { width: "100%", padding: "8px 12px", border: "1.5px dashed #ff9900" + "60", borderRadius: 9, background: "transparent", color: "#ff9900", cursor: "pointer", fontSize: 12, fontWeight: 600, fontFamily: F.m, display: "flex", alignItems: "center", justifyContent: "center", gap: 6 } }, "\u2795 Agregar Invitado")
          : h("div", { style: { display: "flex", gap: 6, alignItems: "center", padding: "8px 10px", background: "#ff9900" + "08", borderRadius: 9, border: "1.5px solid #ff9900" + "40" } },
              h("input", { type: "text", placeholder: "Nombre", value: guestName, onChange: function(e) { setGuestName(e.target.value); }, onKeyDown: function(e) { if (e.key === "Enter") addGuest(); }, style: { flex: 1, padding: "6px 8px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: C.tx, fontFamily: F.m, fontSize: 12, minWidth: 0 } }),
              h("div", { style: { display: "flex", alignItems: "center", gap: 3, flexShrink: 0 } },
                h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "Nivel:"),
                h("input", { type: "number", min: 1, max: 100, value: guestRating, onChange: function(e) { setGuestRating(e.target.value); }, style: { width: 42, padding: "6px 4px", background: C.s1, border: "1px solid " + C.bd, borderRadius: 6, color: "#ff9900", fontFamily: F.m, fontSize: 12, fontWeight: 700, textAlign: "center" } })
              ),
              h("button", { onClick: addGuest, style: { padding: "6px 10px", border: "none", borderRadius: 6, background: "#ff9900", color: "#fff", cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m, flexShrink: 0 } }, "\u2713"),
              h("button", { onClick: function() { setGuestShow(false); setGuestName(""); }, style: { padding: "6px 8px", border: "none", borderRadius: 6, background: C.s1, color: C.rd, cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m, flexShrink: 0 } }, "\u2715")
            )
      )
    ),
    // Preview
    preview && !preview.error && (function() {
      var pcfg = preview.cfg;
      var dSec = pcfg.durationSec || pcfg.duration * 60;
      var dLabel = fmtDurationSec(dSec);
      var netSec = pcfg.usedTimeSec || pcfg.usedTime * 60;
      var deadSec = pcfg.deadTimeSec || pcfg.deadTime * 60;
      var netLabel = fmtDurationSec(netSec);
      var deadLabel = fmtDurationSec(deadSec);
      return h(Box, { style: { marginBottom: 16, padding: 16 }, accent: C.cy, glow: true },
        h(Label, { icon: "\u26a1", text: "Previa automatica" }),
        h("div", { style: { display: "flex", flexWrap: "wrap", gap: 14, justifyContent: "center", marginBottom: 14 } },
          h(Num, { label: "Juego", value: dLabel, sm: true }),
          h(Num, { label: "Rondas", value: pcfg.rounds, color: C.tx, sm: true }),
          h(Num, { label: "Fase 1", value: preview.p1Rounds, color: C.cy, sm: true }),
          h(Num, { label: "Fase 2", value: preview.p2Rounds, color: C.gl, sm: true }),
          h(Num, { label: "J/Jugador", value: pcfg.remainder === 0 ? pcfg.gamesFloor : pcfg.gamesFloor + "-" + pcfg.gamesCeil, color: pcfg.remainder === 0 ? C.gn : C.gl, sm: true })
        ),
        // Time breakdown bar (all 4 boxes in one row)
        (function() {
          var gMin = pcfg.gamesFloor;
          var gMax = pcfg.gamesCeil;
          var playSecMin = gMin * dSec;
          var playSecMax = gMax * dSec;
          var totalSec = totalTime * 60;
          var restSecMax = totalSec - playSecMin;
          var restSecMin = totalSec - playSecMax;
          var same = gMin === gMax;
          var bx = { display: "flex", alignItems: "center", gap: 6, padding: "6px 10px", borderRadius: 8, flex: "1 1 0" };
          return h("div", { style: { display: "flex", gap: 6, justifyContent: "center", marginBottom: 14, flexWrap: "wrap" } },
            h("div", { style: Object.assign({}, bx, { background: C.gn + "10", border: "1px solid " + C.gn + "25" }) },
              h("span", { style: { fontSize: 13 } }, "\u23f1"),
              h("div", null,
                h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 700, textTransform: "uppercase", letterSpacing: 1 } }, "Neto Jugado"),
                h("div", { style: { fontSize: 15, fontWeight: 800, color: C.gn, fontFamily: F.m } }, netLabel)
              )
            ),
            deadSec > 0 ? h("div", { style: Object.assign({}, bx, { background: C.or + "10", border: "1px solid " + C.or + "25" }) },
              h("span", { style: { fontSize: 13 } }, "\u23f8"),
              h("div", null,
                h("div", { style: { fontSize: 9, color: C.or, fontFamily: F.m, fontWeight: 700, textTransform: "uppercase", letterSpacing: 1 } }, "T. Muerto"),
                h("div", { style: { fontSize: 15, fontWeight: 800, color: C.or, fontFamily: F.m } }, deadLabel)
              )
            ) : h("div", { style: Object.assign({}, bx, { background: C.gn + "10", border: "1px solid " + C.gn + "25" }) },
              h("span", { style: { fontSize: 13 } }, "\u2705"),
              h("div", null,
                h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 700, textTransform: "uppercase", letterSpacing: 1 } }, "Optimizado"),
                h("div", { style: { fontSize: 12, fontWeight: 800, color: C.gn, fontFamily: F.m } }, "0:00 muerto")
              )
            ),
            h("div", { style: Object.assign({}, bx, { background: C.cy + "10", border: "1px solid " + C.cy + "25" }) },
              h("span", { style: { fontSize: 13 } }, "\ud83c\udfbe"),
              h("div", null,
                h("div", { style: { fontSize: 9, color: C.cy, fontFamily: F.m, fontWeight: 700, textTransform: "uppercase", letterSpacing: 1 } }, "Jugado/Jug"),
                h("div", { style: { fontSize: 15, fontWeight: 800, color: C.cy, fontFamily: F.m } }, same ? fmtDurationSec(playSecMin) : fmtDurationSec(playSecMin) + "-" + fmtDurationSec(playSecMax))
              )
            ),
            h("div", { style: Object.assign({}, bx, { background: C.tm + "10", border: "1px solid " + C.tm + "25" }) },
              h("span", { style: { fontSize: 13 } }, "\ud83e\ude91"),
              h("div", null,
                h("div", { style: { fontSize: 9, color: C.tm, fontFamily: F.m, fontWeight: 700, textTransform: "uppercase", letterSpacing: 1 } }, "Descanso/Jug"),
                h("div", { style: { fontSize: 15, fontWeight: 800, color: C.tm, fontFamily: F.m } }, same ? fmtDurationSec(restSecMin) : fmtDurationSec(restSecMin) + "-" + fmtDurationSec(restSecMax))
              )
            )
          );
        })(),
        h("div", { style: { display: "flex", gap: 10, flexWrap: "wrap", justifyContent: "center", alignItems: "center" } },
          preview.ext && preview.ext.extra <= 20
            ? h("div", { style: { display: "inline-flex", alignItems: "center", gap: 6, padding: "4px 12px", borderRadius: 16, background: C.gl + "14", border: "1px solid " + C.gl + "30" } },
                h("span", { style: { fontSize: 9, fontWeight: 700, color: C.gl, fontFamily: F.m, letterSpacing: .4 } }, "\u26a0 Agrega " + preview.ext.extra + " min para equidad perfecta"),
                h("button", { onClick: function() { setTotalTime(totalTime + preview.ext.extra); }, style: { padding: "3px 10px", border: "none", borderRadius: 12, background: C.gl, color: C.bg, fontSize: 9, fontWeight: 800, fontFamily: F.m, cursor: "pointer", whiteSpace: "nowrap" } }, "+" + preview.ext.extra + " min")
              )
            : preview.ext && preview.ext.extra <= 30
              ? h("div", { style: { display: "inline-flex", alignItems: "center", gap: 6, padding: "4px 12px", borderRadius: 16, background: C.gl + "14", border: "1px solid " + C.gl + "30" } },
                  h("span", { style: { fontSize: 9, fontWeight: 700, color: C.gl, fontFamily: F.m, letterSpacing: .4 } }, "\u26a0 +" + preview.ext.extra + " min = equidad perfecta"),
                  h("button", { onClick: function() { setTotalTime(totalTime + preview.ext.extra); }, style: { padding: "3px 10px", border: "none", borderRadius: 12, background: C.gl, color: C.bg, fontSize: 9, fontWeight: 800, fontFamily: F.m, cursor: "pointer", whiteSpace: "nowrap" } }, "+" + preview.ext.extra + " min")
                )
              : !preview.ext && pcfg.remainder === 0
                ? h(Tag, { text: "\u2713 Equidad Perfecta", color: C.gn })
                : h(Tag, { text: "Desfase " + pcfg.remainder + " (sin ajuste viable)", color: C.or }),
          h(Tag, { text: pcfg.activityPct + "% actividad", color: C.cy })
        ),
      );
    })(),
    preview && preview.error && h(Box, { style: { textAlign: "center", padding: 24, marginBottom: 16 } }, h("span", { style: { fontSize: 28 } }, "\u26a0\ufe0f"), h("div", { style: { color: C.rd, fontSize: 12, marginTop: 6 } }, preview.error)),
    // Selected players summary table
    N >= 4 && h(Box, { style: { marginBottom: 16, padding: 14 } },
      h(Label, { icon: "\ud83c\udfaf", text: "Jugadores en esta Partida (" + N + ")" }),
      h("div", { style: { display: "flex", flexWrap: "wrap", gap: 5 } },
        selectedPlayers.map(function(p, idx) {
          var s = p.stats || {};
          var rc = s.rating > 60 ? C.gn : s.rating > 40 ? C.cy : s.rating > 20 ? C.gl : C.tm;
          return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 6, padding: "5px 10px", background: p.isGuest ? "#ff990010" : C.s1, borderRadius: 7, border: "1px solid " + (p.isGuest ? "#ff990050" : C.bd) } },
            p.isGuest ? h("span", { style: { fontSize: 8, fontWeight: 800, color: "#fff", background: "#ff9900", borderRadius: 3, padding: "1px 4px", fontFamily: F.m } }, "INV") : h("span", { style: { fontSize: 9, fontWeight: 800, color: C.gl, fontFamily: F.m, minWidth: 16 } }, "#" + p.ranking),
            h(Avatar, { nickname: p.nickname, size: 22 }),
            h("span", { style: { fontSize: 11, fontWeight: 700, color: C.tx, fontFamily: F.d } }, p.nickname),
            h("span", { style: { fontSize: 10, color: rc, fontFamily: F.m } }, s.rating ? s.rating.toFixed(0) + "pts" : "NR"),
            h("button", { onClick: function(e) { e.stopPropagation(); togglePlayer(p.id); }, style: { width: 16, height: 16, border: "none", borderRadius: 3, background: C.rd + "20", color: C.rd, cursor: "pointer", fontSize: 10, display: "flex", alignItems: "center", justifyContent: "center", marginLeft: 2 } }, "\u2715")
          );
        })
      )
    ),
    // Create button
    h("div", { style: { textAlign: "center", marginBottom: 20 } },
      h(Btn, { onClick: handleCreate, disabled: !canCreate, color: C.gn, style: { padding: "14px 40px", fontSize: 14, borderRadius: 12 } }, "\ud83c\udfc6 Generar Partida \u2014 " + date + " " + hour + ":" + minute),
      N < 4 && h("div", { style: { fontSize: 10, color: C.rd, marginTop: 6 } }, "Selecciona al menos 4 jugadores")
    )
  );
}

// ============================================================
// SESSION DETAIL
// ============================================================
function SessionDetail(props) {
  var session = props.session, onBack = props.onBack, onUpdateScores = props.onUpdateScores, onEditSession = props.onEditSession, onUpdateRanking = props.onUpdateRanking, onDeleteRound = props.onDeleteRound, allPlayers = props.allPlayers || [];
  var openState = React.useState(null);
  var open = openState[0], setOpen = openState[1];
  var editingState = React.useState(false);
  var editing = editingState[0], setEditing = editingState[1];
  var confirmDelState = React.useState(null);
  var confirmDel = confirmDelState[0], setConfirmDel = confirmDelState[1];
  var editSelState = React.useState(function() {
    var obj = {};
    (session.players || []).forEach(function(p) { obj[p.id] = true; });
    return obj;
  });
  var editSel = editSelState[0], setEditSel = editSelState[1];
  var scores = session.scores || {};
  var setScore = function(roundNum, courtNum, team, val) {
    var key = roundNum + "-" + courtNum;
    var prev = scores[key] || { s1: "", s2: "" };
    var next = Object.assign({}, prev);
    next[team] = val;
    onUpdateScores(key, next);
  };

  var toggleEditPlayer = function(id) {
    setEditSel(function(prev) { var next = Object.assign({}, prev); if (next[id]) delete next[id]; else next[id] = true; return next; });
  };
  var applyEdit = function() {
    var newPlayers = allPlayers.filter(function(p) { return editSel[p.id]; }).sort(function(a, b) { return a.ranking - b.ranking; });
    if (newPlayers.length < 4) { alert("Minimo 4 jugadores"); return; }
    onEditSession(newPlayers);
    setEditing(false);
  };
  var editCount = Object.keys(editSel).length;

  // ===== GAME TIMER / ALARM =====
  var timerRunState = React.useState(false);
  var timerRunning = timerRunState[0], setTimerRunning = timerRunState[1];
  var timerElapsedState = React.useState(0); // seconds elapsed since start
  var timerElapsed = timerElapsedState[0], setTimerElapsed = timerElapsedState[1];
  var timerAlarmState = React.useState(false); // true when alarm is sounding
  var timerAlarm = timerAlarmState[0], setTimerAlarm = timerAlarmState[1];
  var timerIntervalRef = React.useRef(null);
  var alarmTimeoutRef = React.useRef(null);
  var audioCtxRef = React.useRef(null);
  var alarmIntervalRef = React.useRef(null);

  // Get game duration in seconds
  var gameDurationSec = (session.result && session.result.cfg) ? (session.result.cfg.durationSec || session.result.cfg.duration * 60) : 600;
  var totalRounds = (session.result && session.result.cfg) ? session.result.cfg.rounds : 1;

  // Current round based on elapsed time
  var currentTimerRound = Math.floor(timerElapsed / gameDurationSec) + 1;
  var timeInCurrentRound = timerElapsed % gameDurationSec;
  var timeLeftInRound = gameDurationSec - timeInCurrentRound;
  var totalSessionSec = totalRounds * gameDurationSec;
  var sessionFinished = timerElapsed >= totalSessionSec;

  // Beep function using Web Audio API
  var ensureAudioCtx = function() {
    if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
    // Resume if suspended (mobile browser policy)
    if (audioCtxRef.current.state === "suspended") audioCtxRef.current.resume();
    return audioCtxRef.current;
  };

  var playBeep = function(freq, duration, vol) {
    try {
      var ctx = ensureAudioCtx();
      var osc = ctx.createOscillator();
      var gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = "square";
      osc.frequency.value = freq || 880;
      gain.gain.setValueAtTime(vol || 0.5, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + (duration || 0.25));
      osc.start();
      osc.stop(ctx.currentTime + (duration || 0.25));
    } catch(e) {}
    // Vibrate as fallback (mobile)
    try { if (navigator.vibrate) navigator.vibrate(200); } catch(e) {}
  };

  // Play a loud alarm pattern: 3-tone ascending
  var playAlarmPattern = function() {
    try {
      var ctx = ensureAudioCtx();
      var now = ctx.currentTime;
      // Tone 1
      var o1 = ctx.createOscillator(); var g1 = ctx.createGain();
      o1.connect(g1); g1.connect(ctx.destination);
      o1.type = "square"; o1.frequency.value = 784; g1.gain.value = 0.6;
      o1.start(now); o1.stop(now + 0.15);
      // Tone 2
      var o2 = ctx.createOscillator(); var g2 = ctx.createGain();
      o2.connect(g2); g2.connect(ctx.destination);
      o2.type = "square"; o2.frequency.value = 988; g2.gain.value = 0.6;
      o2.start(now + 0.2); o2.stop(now + 0.35);
      // Tone 3 (higher, longer)
      var o3 = ctx.createOscillator(); var g3 = ctx.createGain();
      o3.connect(g3); g3.connect(ctx.destination);
      o3.type = "square"; o3.frequency.value = 1175; g3.gain.value = 0.7;
      o3.start(now + 0.4); o3.stop(now + 0.7);
    } catch(e) {}
    try { if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]); } catch(e) {}
  };

  // Start alarm: pattern repeatedly for 10 seconds
  var startAlarm = function() {
    setTimerAlarm(true);
    playAlarmPattern();
    var count = 0;
    alarmIntervalRef.current = setInterval(function() {
      count++;
      playAlarmPattern();
      if (count >= 10) {
        clearInterval(alarmIntervalRef.current);
        alarmIntervalRef.current = null;
        setTimerAlarm(false);
      }
    }, 1000);
    // Safety timeout to stop alarm after 11s
    alarmTimeoutRef.current = setTimeout(function() {
      if (alarmIntervalRef.current) clearInterval(alarmIntervalRef.current);
      alarmIntervalRef.current = null;
      setTimerAlarm(false);
    }, 11000);
  };

  // Track previous round to detect round changes
  var prevRoundRef = React.useRef(1);

  React.useEffect(function() {
    if (!timerRunning) return;
    timerIntervalRef.current = setInterval(function() {
      setTimerElapsed(function(prev) {
        var next = prev + 1;
        // Check if round changed
        var prevR = Math.floor(prev / gameDurationSec) + 1;
        var nextR = Math.floor(next / gameDurationSec) + 1;
        if (nextR > prevR && next < totalSessionSec) {
          startAlarm();
        }
        // Session finished
        if (next >= totalSessionSec) {
          startAlarm();
          clearInterval(timerIntervalRef.current);
          setTimerRunning(false);
        }
        return next;
      });
    }, 1000);
    return function() { if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); };
  }, [timerRunning, gameDurationSec, totalSessionSec]);

  // Cleanup on unmount
  React.useEffect(function() {
    return function() {
      if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
      if (alarmIntervalRef.current) clearInterval(alarmIntervalRef.current);
      if (alarmTimeoutRef.current) clearTimeout(alarmTimeoutRef.current);
    };
  }, []);

  var handleStartTimer = function() {
    // Unlock audio on user gesture (required for mobile)
    ensureAudioCtx();
    if (sessionFinished) {
      setTimerElapsed(0);
      setTimerRunning(true);
    } else if (timerRunning) {
      setTimerRunning(false);
    } else {
      setTimerRunning(true);
    }
  };

  var handleResetTimer = function() {
    setTimerRunning(false);
    setTimerElapsed(0);
    setTimerAlarm(false);
    if (alarmIntervalRef.current) clearInterval(alarmIntervalRef.current);
    if (alarmTimeoutRef.current) clearTimeout(alarmTimeoutRef.current);
  };

  var fmtTimerSec = function(s) {
    var mm = Math.floor(s / 60);
    var ss = s % 60;
    return String(mm).padStart(2, "0") + ":" + String(ss).padStart(2, "0");
  };

  var result = session.result, date = session.date, sTime = session.time, totalTime = session.totalTime, numCourts = session.numCourts, sp = session.players;
  var cfg = result.cfg, p1Rounds = result.p1Rounds, p2Rounds = result.p2Rounds;
  var p1Matches = result.p1Matches || { rounds: [], counts: {} };
  var p2Matches = result.p2Matches || null;
  var phase2Generated = result.phase2Generated || false;

  // Check if all Phase 1 scores are complete
  var p1TotalGames = p1Matches.rounds.reduce(function(acc, r) { return acc + r.courts.length; }, 0);
  var p1Filled = 0;
  p1Matches.rounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      var sk = r.round + "-" + c.court;
      var sc = scores[sk];
      if (sc && sc.s1 !== "" && sc.s2 !== "" && !isNaN(parseInt(sc.s1)) && !isNaN(parseInt(sc.s2))) p1Filled++;
    });
  });
  var p1Complete = p1TotalGames > 0 && p1Filled === p1TotalGames;

  // Compute day ranking from Phase 1 scores
  var dayRanking = p1Filled > 0 ? computeDayRanking(p1Matches.rounds, scores, sp) : [];

  // Generate Phase 2 handler
  var onGeneratePhase2 = props.onGeneratePhase2;
  var handleGenerateP2 = function() {
    if (!p1Complete || !onGeneratePhase2) return;
    onGeneratePhase2(dayRanking);
  };

  // Combine rounds for display
  var allRounds = p1Matches.rounds.slice();
  if (phase2Generated && p2Matches) {
    allRounds = allRounds.concat(p2Matches.rounds);
  }

  // Compute combined counts
  var counts = {};
  sp.forEach(function(p) { counts[p.id] = 0; });
  allRounds.forEach(function(r) {
    r.playing.forEach(function(p) {
      if (counts[p.id] !== undefined) counts[p.id]++;
    });
  });
  var vals = Object.values(counts);
  var maxG = vals.length > 0 ? Math.max.apply(null, vals) : 0;
  var minG = vals.length > 0 ? Math.min.apply(null, vals) : 0;
  var fmtTime = function(totalSec) { var h = Math.floor(totalSec / 3600) % 24; var m = Math.floor((totalSec % 3600) / 60); return String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0"); };
  var baseMinSec = (parseInt(sTime.split(":")[0]) * 60 + parseInt(sTime.split(":")[1])) * 60; // base in seconds
  var gameSec = cfg.durationSec || cfg.duration * 60;

  return h("div", null,
    h("div", { style: { display: "flex", alignItems: "center", gap: 10, marginBottom: 16 } },
      h("button", { onClick: onBack, style: { padding: "6px 12px", border: "1px solid " + C.bd, borderRadius: 7, background: "transparent", color: C.cy, cursor: "pointer", fontSize: 11, fontFamily: F.m } }, "\u2190 Volver"),
      h("div", { style: { flex: 1 } },
        h("div", { style: { fontSize: 15, fontWeight: 800, color: C.tx, fontFamily: F.d } }, "\ud83d\udcc5 " + date + " \u00b7 " + sTime),
        h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, sp.length + " jugadores \u00b7 " + numCourts + " pistas \u00b7 " + totalTime + " min \u00b7 " + fmtDurationSec(cfg.durationSec || cfg.duration * 60) + " por juego")
      ),
      h("button", { onClick: function() { setEditing(!editing); if (!editing) { var obj = {}; sp.forEach(function(p) { obj[p.id] = true; }); setEditSel(obj); } }, style: { padding: "6px 12px", border: "1px solid " + (editing ? C.or : C.bd), borderRadius: 7, background: editing ? C.or + "18" : "transparent", color: editing ? C.or : C.tm, cursor: "pointer", fontSize: 10, fontFamily: F.m, fontWeight: 700 } }, editing ? "\u2715 Cancelar" : "\u270f\ufe0f Editar Jugadores")
    ),
    // Edit players panel
    editing && h(Box, { style: { marginBottom: 16, padding: 14 }, accent: C.or },
      h(Label, { icon: "\u270f\ufe0f", text: "Editar Jugadores de la Partida", color: C.or }),
      h("div", { style: { fontSize: 9, color: C.tm, marginBottom: 10, fontFamily: F.m } }, "Seleccionados: " + editCount + " | Se regeneraran las rondas (los marcadores se mantienen donde sea posible)"),
      h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(120px, 1fr))", gap: 5, marginBottom: 12 } },
        allPlayers.slice().sort(function(a, b) { return a.ranking - b.ranking; }).map(function(p) {
          var sel = !!editSel[p.id];
          return h("div", { key: p.id, onClick: function() { toggleEditPlayer(p.id); }, style: { display: "flex", alignItems: "center", gap: 6, padding: "6px 8px", background: sel ? C.or + "10" : C.s1, borderRadius: 7, border: "1.5px solid " + (sel ? C.or + "60" : C.bd), cursor: "pointer", opacity: sel ? 1 : .4 } },
            h(Avatar, { nickname: p.nickname, size: 22 }),
            h("span", { style: { fontSize: 10, fontWeight: 700, color: sel ? C.tx : C.tm, fontFamily: F.d } }, p.nickname),
            h("div", { style: { width: 14, height: 14, borderRadius: 3, border: "2px solid " + (sel ? C.or : C.bd), background: sel ? C.or : "transparent", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 10, color: C.bg, fontWeight: 800, flexShrink: 0, marginLeft: "auto" } }, sel ? "\u2713" : "")
          );
        })
      ),
      h("div", { style: { display: "flex", gap: 8, justifyContent: "center" } },
        h(Btn, { onClick: applyEdit, disabled: editCount < 4, color: C.gn, style: { padding: "8px 20px", fontSize: 11 } }, "\u2713 Aplicar Cambios (" + editCount + " jugadores)"),
        h("button", { onClick: function() { setEditing(false); }, style: { padding: "8px 16px", border: "1px solid " + C.bd, borderRadius: 7, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 10, fontFamily: F.m } }, "Cancelar")
      )
    ),
    // ===== GAME TIMER / ALARM =====
    h(Box, { style: { marginBottom: 16, padding: 14, background: timerAlarm ? C.rd + "18" : (timerRunning ? C.gn + "08" : C.s2), border: "1px solid " + (timerAlarm ? C.rd + "60" : timerRunning ? C.gn + "40" : C.bd), transition: "all .3s" }, accent: timerRunning ? C.gn : C.cy },
      h("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: timerRunning || timerElapsed > 0 ? 12 : 0 } },
        h("div", { style: { display: "flex", alignItems: "center", gap: 8 } },
          h("span", { style: { fontSize: 18 } }, timerAlarm ? "\ud83d\udd14" : timerRunning ? "\u23f1" : "\u23f0"),
          h("div", null,
            h("div", { style: { fontSize: 11, fontWeight: 700, color: C.tx, fontFamily: F.d } }, "Alarma de Cambio de Juego"),
            h("div", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "Intervalo: " + fmtDurationSec(gameDurationSec) + " por juego \u00b7 " + totalRounds + " rondas")
          )
        ),
        h("div", { style: { display: "flex", gap: 6, alignItems: "center" } },
          (timerRunning || timerElapsed > 0) && h("button", { onClick: handleResetTimer, style: { padding: "6px 12px", border: "1px solid " + C.bd, borderRadius: 7, background: "transparent", color: C.rd, cursor: "pointer", fontSize: 10, fontFamily: F.m, fontWeight: 700 } }, "\u21bb Reset"),
          h("button", { onClick: handleStartTimer, style: { padding: "8px 18px", border: "none", borderRadius: 8, background: sessionFinished ? C.cy : (timerRunning ? C.rd : C.gn), color: C.bg, cursor: "pointer", fontSize: 12, fontWeight: 800, fontFamily: F.d, minWidth: 80 } }, sessionFinished ? "\u21bb Reiniciar" : (timerRunning ? "\u23f8 Pausar" : "\u25b6 START"))
        )
      ),
      // Timer display (only when started)
      (timerRunning || timerElapsed > 0) && h("div", null,
        // Alarm alert
        timerAlarm && h("div", { style: { textAlign: "center", padding: "10px 0", marginBottom: 10, background: C.rd + "15", borderRadius: 8, border: "1px solid " + C.rd + "40", animation: "timerPulse 0.5s ease-in-out infinite alternate" } },
          h("div", { style: { fontSize: 22, fontWeight: 800, color: C.rd, fontFamily: F.d } }, "\ud83d\udd14 \u00a1CAMBIO DE JUEGO! \ud83d\udd14"),
          h("div", { style: { fontSize: 10, color: C.rd, fontFamily: F.m, marginTop: 4 } }, "Ronda " + (currentTimerRound > totalRounds ? totalRounds : currentTimerRound - 1) + " terminada")
        ),
        // Main timer display
        h("div", { style: { display: "flex", justifyContent: "center", alignItems: "center", gap: 20, flexWrap: "wrap" } },
          // Current round
          h("div", { style: { textAlign: "center" } },
            h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1.5 } }, "Ronda"),
            h("div", { style: { fontSize: 28, fontWeight: 800, color: sessionFinished ? C.gn : C.gl, fontFamily: F.m } }, sessionFinished ? "\u2713" : Math.min(currentTimerRound, totalRounds) + "/" + totalRounds)
          ),
          // Time left in round
          h("div", { style: { textAlign: "center" } },
            h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1.5 } }, sessionFinished ? "Finalizado" : "Tiempo restante"),
            h("div", { style: { fontSize: 38, fontWeight: 800, color: sessionFinished ? C.gn : (timeLeftInRound <= 30 ? C.rd : C.tx), fontFamily: F.m, letterSpacing: 2, transition: "color .3s" } }, sessionFinished ? "00:00" : fmtTimerSec(timeLeftInRound))
          ),
          // Total elapsed
          h("div", { style: { textAlign: "center" } },
            h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, textTransform: "uppercase", letterSpacing: 1.5 } }, "Transcurrido"),
            h("div", { style: { fontSize: 18, fontWeight: 700, color: C.tm, fontFamily: F.m } }, fmtTimerSec(Math.min(timerElapsed, totalSessionSec)) + " / " + fmtTimerSec(totalSessionSec))
          )
        ),
        // Progress bar
        h("div", { style: { marginTop: 12, height: 6, background: C.s1, borderRadius: 3, overflow: "hidden" } },
          h("div", { style: { height: "100%", width: Math.min(100, timerElapsed / totalSessionSec * 100) + "%", background: sessionFinished ? C.gn : "linear-gradient(90deg, " + C.cy + ", " + C.gl + ")", borderRadius: 3, transition: "width 1s linear" } })
        ),
        // Round markers
        h("div", { style: { display: "flex", justifyContent: "space-between", marginTop: 4 } },
          Array.from({ length: totalRounds + 1 }, function(_, i) {
            var pos = i / totalRounds * 100;
            var passed = timerElapsed >= i * gameDurationSec;
            return h("div", { key: i, style: { fontSize: 9, color: passed ? C.gn : C.td, fontFamily: F.m, fontWeight: 600 } }, i === 0 ? "0" : (i === totalRounds ? "Fin" : "R" + i));
          })
        )
      )
    ),
    // Summary
    h(Box, { style: { marginBottom: 16, padding: 14 }, glow: true, accent: C.cy },
      h("div", { style: { display: "flex", flexWrap: "wrap", gap: 10, justifyContent: "center" } },
        h(Num, { label: "Rondas", value: cfg.rounds, sm: true }),
        h(Num, { label: "Fase 1", value: p1Rounds, color: C.cy, sm: true }),
        h(Num, { label: "Fase 2", value: p2Rounds, color: C.gl, sm: true }),
        h(Num, { label: "Juegos/Jug", value: cfg.remainder === 0 ? cfg.gamesFloor : cfg.gamesFloor + "-" + cfg.gamesCeil, color: cfg.remainder === 0 ? C.gn : C.gl, sm: true }),
        h(Num, { label: "Neto", value: fmtDurationSec(cfg.usedTimeSec || cfg.usedTime * 60), color: C.gn, sm: true })
      )
    ),
    // Phase boxes with status
    h("div", { style: { display: "flex", gap: 8, marginBottom: 16 } },
      h(Box, { style: { flex: 1, padding: 12 }, accent: C.cy }, h("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, h("span", null, "\ud83d\udd00"), h("div", null, h("div", { style: { fontSize: 11, fontWeight: 700, color: C.tx } }, "Fase 1: Mezcla Social"), h("div", { style: { fontSize: 9, color: p1Complete ? C.gn : C.or } }, p1Complete ? "\u2713 Completa (" + p1Filled + "/" + p1TotalGames + ")" : p1Filled + "/" + p1TotalGames + " capturados")))),
      h(Box, { style: { flex: 1, padding: 12 }, accent: C.gl }, h("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, h("span", null, "\ud83d\udc51"), h("div", null, h("div", { style: { fontSize: 11, fontWeight: 700, color: C.tx } }, "Fase 2: King of Court"), h("div", { style: { fontSize: 9, color: phase2Generated ? C.gn : C.td } }, phase2Generated ? "\u2713 Generada \u00b7 " + p2Rounds + " rondas" : "\ud83d\udd12 Pendiente \u2014 captura Fase 1"))))
    ),
    // Games per player
    h(Box, { style: { marginBottom: 16, padding: 14 } },
      h(Label, { icon: "\ud83d\udcca", text: "Partidos por Jugador" }),
      h("div", { style: { display: "flex", flexWrap: "wrap", gap: 5 } },
        sp.map(function(p) {
          var g = counts[p.id] || 0;
          return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 5, padding: "4px 9px", background: C.s1, borderRadius: 7, border: "1px solid " + (g === maxG ? C.gn + "30" : g === minG ? C.or + "30" : C.bd) } },
            h(Avatar, { nickname: p.nickname, size: 20 }),
            h("span", { style: { fontSize: 10, fontWeight: 700, color: C.tx, fontFamily: F.d } }, p.nickname),
            h("span", { style: { fontSize: 12, fontWeight: 800, color: g === maxG ? C.gn : g === minG ? C.or : C.tm, fontFamily: F.m } }, g)
          );
        })
      )
    ),
    // Phase 1 Rounds
    h("div", { style: { marginBottom: 4 } },
      h("div", { style: { fontSize: 10, fontWeight: 700, color: C.cy, fontFamily: F.m, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8, paddingLeft: 4 } }, "\ud83d\udd00 FASE 1 \u2014 MEZCLA SOCIAL (" + p1Rounds + " rondas)")
    ),
    p1Matches.rounds.map(function(r) {
      var ex = open === r.round;
      var pc = C.cy;
      var s0 = baseMinSec + (r.round - 1) * gameSec;
      var s1 = baseMinSec + r.round * gameSec;
      var completedCourts = r.courts.filter(function(c) { var sc = scores[r.round + "-" + c.court]; return sc && sc.s1 !== "" && sc.s2 !== ""; }).length;
      return h(Box, { key: r.round, style: { marginBottom: 8, padding: 0, cursor: "pointer" }, accent: pc },
        h("div", { onClick: function() { setOpen(ex ? null : r.round); }, style: { padding: "12px 16px", display: "flex", alignItems: "center", justifyContent: "space-between" } },
          h("div", { style: { display: "flex", alignItems: "center", gap: 10 } },
            h("div", { style: { width: 32, height: 32, borderRadius: 8, background: pc + "15", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 14, fontWeight: 800, color: pc, fontFamily: F.m } }, r.round),
            h("div", null,
              h("div", { style: { fontSize: 12, fontWeight: 700, color: C.tx } }, "Ronda " + r.round + " ", h("span", { style: { fontSize: 9, color: C.td } }, "\u00b7 " + fmtTime(s0) + "-" + fmtTime(s1))),
              h("div", { style: { fontSize: 9, color: pc } }, "\ud83d\udd00 " + r.phaseLabel)
            )
          ),
          h("div", { style: { display: "flex", alignItems: "center", gap: 6 } },
            r.resting.length > 0 && h(Tag, { text: "\ud83e\ude91 " + r.resting.length, color: C.td, sm: true }),
            completedCourts > 0 && h(Tag, { text: completedCourts + "/" + r.courts.length, color: completedCourts === r.courts.length ? C.gn : C.or, sm: true }),
            h(Tag, { text: r.courts.length + " pista" + (r.courts.length > 1 ? "s" : ""), color: pc, sm: true }),
            h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(confirmDel === r.round ? null : r.round); }, style: { width: 22, height: 22, border: "none", borderRadius: 5, background: confirmDel === r.round ? C.rd + "30" : "transparent", color: C.rd, cursor: "pointer", fontSize: 11, display: "flex", alignItems: "center", justifyContent: "center", opacity: 0.5, transition: "all .2s" }, title: "Eliminar ronda" }, "\ud83d\uddd1\ufe0f"),
            h("span", { style: { color: C.td, fontSize: 10, transition: "transform .2s", transform: ex ? "rotate(180deg)" : "" } }, "\u25bc")
          )
        ),
        confirmDel === r.round && h("div", { style: { padding: "8px 16px", background: C.rd + "08", borderTop: "1px solid " + C.rd + "30", display: "flex", alignItems: "center", justifyContent: "space-between" } },
          h("span", { style: { fontSize: 11, color: C.rd, fontFamily: F.m, fontWeight: 600 } }, "\u26a0\ufe0f Eliminar Ronda " + r.round + "?"),
          h("div", { style: { display: "flex", gap: 6 } },
            h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(null); onDeleteRound(r.round); }, style: { padding: "5px 14px", border: "none", borderRadius: 6, background: C.rd, color: "#fff", cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m } }, "\u2713 Si, eliminar"),
            h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(null); }, style: { padding: "5px 14px", border: "1px solid " + C.bd, borderRadius: 6, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 11, fontFamily: F.m } }, "Cancelar")
          )
        ),
        ex && h("div", { style: { padding: "0 16px 16px", borderTop: "1px solid " + C.bd } },
          h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))", gap: 8, marginTop: 12 } },
            r.courts.map(function(c) {
              var tierColors = { "Oro": C.gl, "Plata": C.si, "Bronce": C.bz, "Hierro": "#8d6e63", "Madera": "#a1887f", "Social": C.cy };
              var tc = tierColors[c.tier] || C.tm;
              var sk = r.round + "-" + c.court;
              var sc = scores[sk] || { s1: "", s2: "" };
              var s1n = sc.s1 === "" ? null : parseInt(sc.s1);
              var s2n = sc.s2 === "" ? null : parseInt(sc.s2);
              var hasScore = s1n !== null && s2n !== null && !isNaN(s1n) && !isNaN(s2n);
              var w1 = hasScore && s1n > s2n;
              var w2 = hasScore && s2n > s1n;
              return h("div", { key: c.court, style: { background: C.s1, borderRadius: 9, padding: 12, border: "1px solid " + tc + "22" } },
                h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 } },
                  h("span", { style: { fontSize: 10, fontWeight: 700, color: C.tx, fontFamily: F.m } }, "Pista " + c.court),
                  h(Tag, { text: c.tier, color: tc, sm: true })
                ),
                h("div", { style: { display: "flex", gap: 4, alignItems: "center" } },
                  h("div", { style: { flex: 1, display: "flex", alignItems: "center", gap: 6, padding: 6, borderRadius: 7, background: w1 ? C.gn + "0c" : "transparent", border: w1 ? "1px solid " + C.gn + "25" : "1px solid transparent" } },
                    h("div", { style: { flex: 1, textAlign: "center" } },
                      c.t1.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 4, marginBottom: 3 } }, h(Avatar, { nickname: p.nickname, size: 24 }), h("span", { style: { fontSize: 12, fontWeight: 600, color: w1 ? C.gn : C.cy } }, p.nickname), h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "#" + p.ranking)); }),
                      w1 && h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 800, marginTop: 3, letterSpacing: 1 } }, "GANADOR")
                    ),
                    h("input", { value: sc.s1, onChange: function(e) { setScore(r.round, c.court, "s1", e.target.value); }, placeholder: "-", onClick: function(e) { e.stopPropagation(); }, style: { width: 36, height: 30, textAlign: "center", background: w1 ? C.gn + "18" : C.s3, border: "1.5px solid " + (w1 ? C.gn + "60" : C.bd), borderRadius: 6, color: w1 ? C.gn : C.tx, fontSize: 16, fontWeight: 800, fontFamily: F.m, outline: "none", flexShrink: 0 } })
                  ),
                  h("div", { style: { fontSize: 10, color: C.td, fontWeight: 800, fontFamily: F.m, lineHeight: 1, padding: "0 2px" } }, "VS"),
                  h("div", { style: { flex: 1, display: "flex", alignItems: "center", gap: 6, padding: 6, borderRadius: 7, background: w2 ? C.gn + "0c" : "transparent", border: w2 ? "1px solid " + C.gn + "25" : "1px solid transparent" } },
                    h("input", { value: sc.s2, onChange: function(e) { setScore(r.round, c.court, "s2", e.target.value); }, placeholder: "-", onClick: function(e) { e.stopPropagation(); }, style: { width: 36, height: 30, textAlign: "center", background: w2 ? C.gn + "18" : C.s3, border: "1.5px solid " + (w2 ? C.gn + "60" : C.bd), borderRadius: 6, color: w2 ? C.gn : C.tx, fontSize: 16, fontWeight: 800, fontFamily: F.m, outline: "none", flexShrink: 0 } }),
                    h("div", { style: { flex: 1, textAlign: "center" } },
                      c.t2.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 4, marginBottom: 3 } }, h(Avatar, { nickname: p.nickname, size: 24 }), h("span", { style: { fontSize: 12, fontWeight: 600, color: w2 ? C.gn : C.or } }, p.nickname), h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "#" + p.ranking)); }),
                      w2 && h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 800, marginTop: 3, letterSpacing: 1 } }, "GANADOR")
                    )
                  )
                )
              );
            })
          ),
          r.resting.length > 0 && h("div", { style: { marginTop: 8, padding: "6px 10px", background: C.td + "08", borderRadius: 6, display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" } },
            h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "Descansan:"),
            r.resting.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 3 } }, h(Avatar, { nickname: p.nickname, size: 16 }), h("span", { style: { fontSize: 10, color: C.tm } }, p.nickname)); })
          )
        )
      );
    }),
    // === DAY RANKING & PHASE 2 GENERATION ===
    h(Box, { style: { marginTop: 12, marginBottom: 12, padding: 16 }, accent: p1Complete ? C.gl : C.td, glow: p1Complete },
      h(Label, { icon: "\ud83c\udfc5", text: "Ranking del D\u00eda \u2014 Fase 1", color: p1Complete ? C.gl : C.td }),
      !p1Complete && h("div", { style: { textAlign: "center", padding: 16 } },
        h("div", { style: { fontSize: 28, marginBottom: 8 } }, "\ud83d\udd12"),
        h("div", { style: { fontSize: 12, color: C.td, fontFamily: F.m } }, "Captura todos los marcadores de Fase 1 (" + p1Filled + "/" + p1TotalGames + ")"),
        h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, marginTop: 4 } }, "El ranking del d\u00eda determina las pistas de Fase 2")
      ),
      p1Complete && dayRanking.length > 0 && h("div", null,
        h("div", { style: { display: "grid", gap: 4, marginBottom: 14 } },
          dayRanking.map(function(s, idx) {
            var medal = idx === 0 ? "\ud83e\udd47" : idx === 1 ? "\ud83e\udd48" : idx === 2 ? "\ud83e\udd49" : "";
            var tierColor = idx < 4 ? C.gl : idx < 8 ? C.si : idx < 12 ? C.bz : C.td;
            var tierName = idx < 4 ? "Oro" : idx < 8 ? "Plata" : idx < 12 ? "Bronce" : idx < 16 ? "Hierro" : "Madera";
            return h("div", { key: s.id, style: { display: "flex", alignItems: "center", gap: 8, padding: "6px 10px", background: C.s1, borderRadius: 7, border: "1px solid " + tierColor + "25" } },
              h("span", { style: { fontSize: 13, fontWeight: 800, color: tierColor, fontFamily: F.m, minWidth: 22, textAlign: "center" } }, medal || (idx + 1)),
              h(Avatar, { nickname: s.player.nickname, size: 24 }),
              h("div", { style: { flex: 1 } },
                h("span", { style: { fontSize: 11, fontWeight: 700, color: C.tx, fontFamily: F.d } }, s.player.nickname)
              ),
              h("span", { style: { fontSize: 11, fontWeight: 800, color: C.gn, fontFamily: F.m } }, s.wins + "W"),
              h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, s.losses + "L"),
              h("span", { style: { fontSize: 10, fontWeight: 700, color: s.diff > 0 ? C.gn : s.diff < 0 ? C.rd : C.td, fontFamily: F.m } }, (s.diff > 0 ? "+" : "") + s.diff),
              h(Tag, { text: tierName, color: tierColor, sm: true })
            );
          })
        ),
        !phase2Generated && h("div", { style: { textAlign: "center" } },
          h(Btn, { onClick: handleGenerateP2, color: C.gl, style: { padding: "14px 36px", fontSize: 13, borderRadius: 10 } }, "\ud83d\udc51 Generar Fase 2 \u2014 King of the Court"),
          h("div", { style: { fontSize: 9, color: C.td, marginTop: 6, fontFamily: F.m } }, "Los mejores 4 van a Pista Oro, siguientes a Plata, etc.")
        ),
        phase2Generated && h("div", { style: { textAlign: "center", padding: "6px 0" } },
          h(Tag, { text: "\u2713 Fase 2 generada con ranking del d\u00eda", color: C.gn })
        )
      )
    ),
    // === PHASE 2 ROUNDS ===
    phase2Generated && p2Matches && p2Matches.rounds.length > 0 && h("div", null,
      h("div", { style: { fontSize: 10, fontWeight: 700, color: C.gl, fontFamily: F.m, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8, marginTop: 8, paddingLeft: 4 } }, "\ud83d\udc51 FASE 2 \u2014 KING OF THE COURT (" + p2Rounds + " rondas)"),
      p2Matches.rounds.map(function(r) {
        var ex = open === r.round;
        var pc = C.gl;
        var s0 = baseMinSec + (r.round - 1) * gameSec;
        var s1 = baseMinSec + r.round * gameSec;
        var completedCourts = r.courts.filter(function(c) { var sc = scores[r.round + "-" + c.court]; return sc && sc.s1 !== "" && sc.s2 !== ""; }).length;
        return h(Box, { key: r.round, style: { marginBottom: 8, padding: 0, cursor: "pointer" }, accent: pc },
          h("div", { onClick: function() { setOpen(ex ? null : r.round); }, style: { padding: "12px 16px", display: "flex", alignItems: "center", justifyContent: "space-between" } },
            h("div", { style: { display: "flex", alignItems: "center", gap: 10 } },
              h("div", { style: { width: 32, height: 32, borderRadius: 8, background: pc + "15", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 14, fontWeight: 800, color: pc, fontFamily: F.m } }, r.round),
              h("div", null,
                h("div", { style: { fontSize: 12, fontWeight: 700, color: C.tx } }, "Ronda " + r.round + " ", h("span", { style: { fontSize: 9, color: C.td } }, "\u00b7 " + fmtTime(s0) + "-" + fmtTime(s1))),
                h("div", { style: { fontSize: 9, color: pc } }, "\ud83d\udc51 " + r.phaseLabel)
              )
            ),
            h("div", { style: { display: "flex", alignItems: "center", gap: 6 } },
              r.resting.length > 0 && h(Tag, { text: "\ud83e\ude91 " + r.resting.length, color: C.td, sm: true }),
              completedCourts > 0 && h(Tag, { text: completedCourts + "/" + r.courts.length, color: completedCourts === r.courts.length ? C.gn : C.or, sm: true }),
              h(Tag, { text: r.courts.length + " pista" + (r.courts.length > 1 ? "s" : ""), color: pc, sm: true }),
              h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(confirmDel === r.round ? null : r.round); }, style: { width: 22, height: 22, border: "none", borderRadius: 5, background: confirmDel === r.round ? C.rd + "30" : "transparent", color: C.rd, cursor: "pointer", fontSize: 11, display: "flex", alignItems: "center", justifyContent: "center", opacity: 0.5, transition: "all .2s" }, title: "Eliminar ronda" }, "\ud83d\uddd1\ufe0f"),
              h("span", { style: { color: C.td, fontSize: 10, transition: "transform .2s", transform: ex ? "rotate(180deg)" : "" } }, "\u25bc")
            )
          ),
          confirmDel === r.round && h("div", { style: { padding: "8px 16px", background: C.rd + "08", borderTop: "1px solid " + C.rd + "30", display: "flex", alignItems: "center", justifyContent: "space-between" } },
            h("span", { style: { fontSize: 11, color: C.rd, fontFamily: F.m, fontWeight: 600 } }, "\u26a0\ufe0f Eliminar Ronda " + r.round + "?"),
            h("div", { style: { display: "flex", gap: 6 } },
              h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(null); onDeleteRound(r.round); }, style: { padding: "5px 14px", border: "none", borderRadius: 6, background: C.rd, color: "#fff", cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m } }, "\u2713 Si, eliminar"),
              h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDel(null); }, style: { padding: "5px 14px", border: "1px solid " + C.bd, borderRadius: 6, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 11, fontFamily: F.m } }, "Cancelar")
            )
          ),
          ex && h("div", { style: { padding: "0 16px 16px", borderTop: "1px solid " + C.bd } },
            h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))", gap: 8, marginTop: 12 } },
              r.courts.map(function(c) {
                var tierColors = { "Oro": C.gl, "Plata": C.si, "Bronce": C.bz, "Hierro": "#8d6e63", "Madera": "#a1887f", "Social": C.cy };
                var tc = tierColors[c.tier] || C.tm;
                var sk = r.round + "-" + c.court;
                var sc = scores[sk] || { s1: "", s2: "" };
                var s1n = sc.s1 === "" ? null : parseInt(sc.s1);
                var s2n = sc.s2 === "" ? null : parseInt(sc.s2);
                var hasScore = s1n !== null && s2n !== null && !isNaN(s1n) && !isNaN(s2n);
                var w1 = hasScore && s1n > s2n;
                var w2 = hasScore && s2n > s1n;
                return h("div", { key: c.court, style: { background: C.s1, borderRadius: 9, padding: 12, border: "1px solid " + tc + "22" } },
                  h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 } },
                    h("span", { style: { fontSize: 10, fontWeight: 700, color: C.tx, fontFamily: F.m } }, "Pista " + c.court),
                    h(Tag, { text: c.tier, color: tc, sm: true })
                  ),
                  h("div", { style: { display: "flex", gap: 4, alignItems: "center" } },
                    h("div", { style: { flex: 1, display: "flex", alignItems: "center", gap: 6, padding: 6, borderRadius: 7, background: w1 ? C.gn + "0c" : "transparent", border: w1 ? "1px solid " + C.gn + "25" : "1px solid transparent" } },
                      h("div", { style: { flex: 1, textAlign: "center" } },
                        c.t1.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 4, marginBottom: 3 } }, h(Avatar, { nickname: p.nickname, size: 24 }), h("span", { style: { fontSize: 12, fontWeight: 600, color: w1 ? C.gn : C.cy } }, p.nickname), h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "#" + p.ranking)); }),
                        w1 && h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 800, marginTop: 3, letterSpacing: 1 } }, "GANADOR")
                      ),
                      h("input", { value: sc.s1, onChange: function(e) { setScore(r.round, c.court, "s1", e.target.value); }, placeholder: "-", onClick: function(e) { e.stopPropagation(); }, style: { width: 36, height: 30, textAlign: "center", background: w1 ? C.gn + "18" : C.s3, border: "1.5px solid " + (w1 ? C.gn + "60" : C.bd), borderRadius: 6, color: w1 ? C.gn : C.tx, fontSize: 16, fontWeight: 800, fontFamily: F.m, outline: "none", flexShrink: 0 } })
                    ),
                    h("div", { style: { fontSize: 10, color: C.td, fontWeight: 800, fontFamily: F.m, lineHeight: 1, padding: "0 2px" } }, "VS"),
                    h("div", { style: { flex: 1, display: "flex", alignItems: "center", gap: 6, padding: 6, borderRadius: 7, background: w2 ? C.gn + "0c" : "transparent", border: w2 ? "1px solid " + C.gn + "25" : "1px solid transparent" } },
                      h("input", { value: sc.s2, onChange: function(e) { setScore(r.round, c.court, "s2", e.target.value); }, placeholder: "-", onClick: function(e) { e.stopPropagation(); }, style: { width: 36, height: 30, textAlign: "center", background: w2 ? C.gn + "18" : C.s3, border: "1.5px solid " + (w2 ? C.gn + "60" : C.bd), borderRadius: 6, color: w2 ? C.gn : C.tx, fontSize: 16, fontWeight: 800, fontFamily: F.m, outline: "none", flexShrink: 0 } }),
                      h("div", { style: { flex: 1, textAlign: "center" } },
                        c.t2.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 4, marginBottom: 3 } }, h(Avatar, { nickname: p.nickname, size: 24 }), h("span", { style: { fontSize: 12, fontWeight: 600, color: w2 ? C.gn : C.or } }, p.nickname), h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "#" + p.ranking)); }),
                        w2 && h("div", { style: { fontSize: 9, color: C.gn, fontFamily: F.m, fontWeight: 800, marginTop: 3, letterSpacing: 1 } }, "GANADOR")
                      )
                    )
                  )
                );
              })
            ),
            r.resting.length > 0 && h("div", { style: { marginTop: 8, padding: "6px 10px", background: C.td + "08", borderRadius: 6, display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" } },
              h("span", { style: { fontSize: 9, color: C.td, fontFamily: F.m } }, "Descansan:"),
              r.resting.map(function(p) { return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 3 } }, h(Avatar, { nickname: p.nickname, size: 16 }), h("span", { style: { fontSize: 10, color: C.tm } }, p.nickname)); })
            )
          )
        );
      })
    ),
    // Results summary
    (function() {
      var totalGames = allRounds.reduce(function(acc, r) { return acc + r.courts.length; }, 0);
      var filled = Object.keys(scores).filter(function(k) { var s = scores[k]; return s && s.s1 !== "" && s.s2 !== ""; }).length;
      var wins = {}, ptsFor = {}, ptsAg = {};
      sp.forEach(function(p) { wins[p.id] = 0; ptsFor[p.id] = 0; ptsAg[p.id] = 0; });
      allRounds.forEach(function(r) {
        r.courts.forEach(function(c) {
          var sk = r.round + "-" + c.court;
          var sc = scores[sk];
          if (sc && sc.s1 !== "" && sc.s2 !== "") {
            var s1n = parseInt(sc.s1), s2n = parseInt(sc.s2);
            if (!isNaN(s1n) && !isNaN(s2n)) {
              c.t1.forEach(function(p) { if (wins[p.id] !== undefined) { ptsFor[p.id] += s1n; ptsAg[p.id] += s2n; if (s1n > s2n) wins[p.id]++; } });
              c.t2.forEach(function(p) { if (wins[p.id] !== undefined) { ptsFor[p.id] += s2n; ptsAg[p.id] += s1n; if (s2n > s1n) wins[p.id]++; } });
            }
          }
        });
      });
      var buildText = function() {
        var txt = "PADEL SESSION - " + date + " " + sTime + "\n";
        txt += totalTime + " min | " + sp.length + " jugadores | " + numCourts + " pistas | " + fmtDurationSec(cfg.durationSec || cfg.duration * 60) + " por juego\n";
        txt += "=".repeat(50) + "\n\n";
        allRounds.forEach(function(r) {
          txt += "RONDA " + r.round + " - " + r.phaseLabel + "\n";
          r.courts.forEach(function(c) {
            var sk = r.round + "-" + c.court;
            var sc = scores[sk] || { s1: "-", s2: "-" };
            txt += "  Pista " + c.court + " [" + c.tier + "]: " + c.t1.map(function(p) { return p.nickname; }).join("+") + " (" + sc.s1 + ") vs " + c.t2.map(function(p) { return p.nickname; }).join("+") + " (" + sc.s2 + ")\n";
          });
          if (r.resting.length > 0) txt += "  Descansan: " + r.resting.map(function(p) { return p.nickname; }).join(", ") + "\n";
          txt += "\n";
        });
        txt += "RESULTADOS\n" + "-".repeat(30) + "\n";
        sp.slice().sort(function(a, b) { return (wins[b.id] || 0) - (wins[a.id] || 0); }).forEach(function(p) { var d = (ptsFor[p.id] || 0) - (ptsAg[p.id] || 0); txt += "  " + p.nickname + ": " + (wins[p.id] || 0) + "W / " + (counts[p.id] || 0) + " jugados | dif: " + (d > 0 ? "+" : "") + d + "\n"; });
        return txt;
      };
      var copyResults = function() {
        var txt = buildText();
        if (navigator.clipboard) navigator.clipboard.writeText(txt).then(function() { alert("Resultados copiados al portapapeles"); });
      };
      if (filled <= 0) return null;
      var isComplete = phase2Generated && filled === totalGames;
      // Sort players by: wins desc, then point diff desc, then win% desc
      var ranked = sp.slice().sort(function(a, b) {
        var wa = wins[a.id] || 0, wb = wins[b.id] || 0;
        if (wb !== wa) return wb - wa;
        // Calculate point diff per player
        var diffA = 0, diffB = 0, ptsForA = 0, ptsAgA = 0, ptsForB = 0, ptsAgB = 0;
        allRounds.forEach(function(r) {
          r.courts.forEach(function(c) {
            var sk = r.round + "-" + c.court;
            var sc = scores[sk];
            if (!sc || sc.s1 === "" || sc.s2 === "") return;
            var s1n = parseInt(sc.s1), s2n = parseInt(sc.s2);
            if (isNaN(s1n) || isNaN(s2n)) return;
            c.t1.forEach(function(p) {
              if (p.id === a.id) { ptsForA += s1n; ptsAgA += s2n; }
              if (p.id === b.id) { ptsForB += s1n; ptsAgB += s2n; }
            });
            c.t2.forEach(function(p) {
              if (p.id === a.id) { ptsForA += s2n; ptsAgA += s1n; }
              if (p.id === b.id) { ptsForB += s2n; ptsAgB += s1n; }
            });
          });
        });
        diffA = ptsForA - ptsAgA; diffB = ptsForB - ptsAgB;
        if (diffB !== diffA) return diffB - diffA;
        var ga = counts[a.id] || 1, gb = counts[b.id] || 1;
        return (wb / gb) - (wa / ga);
      });
      var medals = ["\ud83e\udd47", "\ud83e\udd48", "\ud83e\udd49"];
      return h("div", null,
        // Podium when tournament is complete
        isComplete && h(Box, { style: { marginTop: 16, padding: 20, textAlign: "center" }, accent: C.gl, glow: true },
          h("div", { style: { fontSize: 28, marginBottom: 4 } }, "\ud83c\udfc6"),
          h("div", { style: { fontSize: 18, fontWeight: 800, color: C.gl, fontFamily: F.d, marginBottom: 4 } }, "TORNEO FINALIZADO"),
          h("div", { style: { fontSize: 10, color: C.tm, fontFamily: F.m, marginBottom: 16 } }, date + " \u00b7 " + sp.length + " jugadores \u00b7 " + totalGames + " juegos"),
          h("div", { style: { display: "flex", justifyContent: "center", alignItems: "flex-end", gap: 12, marginBottom: 16 } },
            // 2nd place
            ranked.length > 1 && h("div", { style: { textAlign: "center" } },
              h("div", { style: { fontSize: 24 } }, "\ud83e\udd48"),
              h("div", { style: { background: C.si + "18", borderRadius: 10, padding: "12px 16px", border: "1px solid " + C.si + "40" } },
                h(Avatar, { nickname: ranked[1].nickname, size: 40, style: { margin: "0 auto 4px" } }),
                h("div", { style: { fontSize: 13, fontWeight: 800, color: C.si, fontFamily: F.d } }, ranked[1].nickname),
                h("div", { style: { fontSize: 18, fontWeight: 800, color: C.tx, fontFamily: F.m } }, (wins[ranked[1].id] || 0) + "W"),
                h("div", { style: { fontSize: 10, fontWeight: 700, color: (ptsFor[ranked[1].id] - ptsAg[ranked[1].id]) > 0 ? C.gn : (ptsFor[ranked[1].id] - ptsAg[ranked[1].id]) < 0 ? C.rd : C.td, fontFamily: F.m } }, ((ptsFor[ranked[1].id] - ptsAg[ranked[1].id]) > 0 ? "+" : "") + (ptsFor[ranked[1].id] - ptsAg[ranked[1].id]) + " dif")
              )
            ),
            // 1st place (center, larger)
            ranked.length > 0 && h("div", { style: { textAlign: "center" } },
              h("div", { style: { fontSize: 32 } }, "\ud83e\udd47"),
              h("div", { style: { background: C.gl + "18", borderRadius: 12, padding: "16px 24px", border: "2px solid " + C.gl + "60", boxShadow: "0 0 30px " + C.gl + "20" } },
                h(Avatar, { nickname: ranked[0].nickname, size: 52, style: { margin: "0 auto 6px" } }),
                h("div", { style: { fontSize: 16, fontWeight: 800, color: C.gl, fontFamily: F.d } }, ranked[0].nickname),
                h("div", { style: { fontSize: 22, fontWeight: 800, color: C.tx, fontFamily: F.m } }, (wins[ranked[0].id] || 0) + "W"),
                h("div", { style: { fontSize: 10, fontWeight: 700, color: (ptsFor[ranked[0].id] - ptsAg[ranked[0].id]) > 0 ? C.gn : (ptsFor[ranked[0].id] - ptsAg[ranked[0].id]) < 0 ? C.rd : C.td, fontFamily: F.m } }, ((ptsFor[ranked[0].id] - ptsAg[ranked[0].id]) > 0 ? "+" : "") + (ptsFor[ranked[0].id] - ptsAg[ranked[0].id]) + " dif"),
                h("div", { style: { fontSize: 9, color: C.gl, fontFamily: F.m, marginTop: 2 } }, "\ud83d\udc51 KING OF THE COURT")
              )
            ),
            // 3rd place
            ranked.length > 2 && h("div", { style: { textAlign: "center" } },
              h("div", { style: { fontSize: 24 } }, "\ud83e\udd49"),
              h("div", { style: { background: C.bz + "18", borderRadius: 10, padding: "12px 16px", border: "1px solid " + C.bz + "40" } },
                h(Avatar, { nickname: ranked[2].nickname, size: 40, style: { margin: "0 auto 4px" } }),
                h("div", { style: { fontSize: 13, fontWeight: 800, color: C.bz, fontFamily: F.d } }, ranked[2].nickname),
                h("div", { style: { fontSize: 18, fontWeight: 800, color: C.tx, fontFamily: F.m } }, (wins[ranked[2].id] || 0) + "W"),
                h("div", { style: { fontSize: 10, fontWeight: 700, color: (ptsFor[ranked[2].id] - ptsAg[ranked[2].id]) > 0 ? C.gn : (ptsFor[ranked[2].id] - ptsAg[ranked[2].id]) < 0 ? C.rd : C.td, fontFamily: F.m } }, ((ptsFor[ranked[2].id] - ptsAg[ranked[2].id]) > 0 ? "+" : "") + (ptsFor[ranked[2].id] - ptsAg[ranked[2].id]) + " dif")
              )
            )
          )
        ),
        // Full results table
        h(Box, { style: { marginTop: isComplete ? 12 : 16, padding: 14 }, accent: C.gl },
          h(Label, { icon: isComplete ? "\ud83c\udfc6" : "\ud83d\udcca", text: isComplete ? "Resultados Finales" : "Resultados Parciales", color: C.gl }),
          h("div", { style: { fontSize: 10, color: C.tm, marginBottom: 10, fontFamily: F.m } }, filled + "/" + totalGames + " juegos registrados" + (isComplete ? " \u2714\ufe0f COMPLETO" : "")),
          h("div", { style: { display: "grid", gap: 4, marginBottom: 14 } },
            ranked.map(function(p, idx) {
              var w = wins[p.id] || 0, g = counts[p.id] || 0, pct = g > 0 ? Math.round(w / g * 100) : 0;
              var diff = (ptsFor[p.id] || 0) - (ptsAg[p.id] || 0);
              var medal = idx < 3 && isComplete ? medals[idx] : "";
              var borderColor = idx === 0 && isComplete ? C.gl + "50" : idx === 1 && isComplete ? C.si + "40" : idx === 2 && isComplete ? C.bz + "40" : (w > 0 ? C.gn + "20" : C.bd);
              return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 8, padding: "6px 10px", background: idx < 3 && isComplete ? (idx === 0 ? C.gl : idx === 1 ? C.si : C.bz) + "08" : C.s1, borderRadius: 8, border: "1px solid " + borderColor } },
                h("span", { style: { fontSize: 10, fontWeight: 800, color: C.td, fontFamily: F.m, width: 20, textAlign: "center" } }, medal || (idx + 1)),
                h(Avatar, { nickname: p.nickname, size: 24 }),
                h("div", { style: { flex: 1 } },
                  h("div", { style: { fontSize: 11, fontWeight: 700, color: C.tx, fontFamily: F.d } }, p.nickname),
                  h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, w + "W / " + (g - w) + "L \u00b7 " + pct + "%")
                ),
                h("span", { style: { fontSize: 10, fontWeight: 700, color: diff > 0 ? C.gn : diff < 0 ? C.rd : C.td, fontFamily: F.m, minWidth: 32, textAlign: "right" } }, (diff > 0 ? "+" : "") + diff),
                h("span", { style: { fontSize: 16, fontWeight: 800, color: w > 0 ? C.gn : C.td, fontFamily: F.m } }, w),
                h("div", { style: { width: Math.max(4, pct * 0.6), height: 6, borderRadius: 3, background: pct >= 60 ? C.gn : pct >= 40 ? C.cy : C.or, marginLeft: 4 } })
              );
            })
          ),
          h("div", { style: { display: "flex", gap: 8, justifyContent: "center", flexWrap: "wrap" } },
            h(Btn, { onClick: copyResults, color: C.cy, style: { padding: "10px 24px", fontSize: 11 } }, "\ud83d\udccb Copiar Resultados"),
            isComplete && onUpdateRanking && !session.rankingUpdated && h(Btn, { onClick: function() {
              // Calculate per-player session stats: played, wins, pointsFor, pointsAgainst
              var sessionStats = {};
              sp.forEach(function(p) { sessionStats[p.id] = { played: 0, wins: 0, pointsFor: 0, pointsAgainst: 0 }; });
              allRounds.forEach(function(r) {
                r.courts.forEach(function(c) {
                  var sk = r.round + "-" + c.court;
                  var sc = scores[sk];
                  if (!sc || sc.s1 === "" || sc.s2 === "") return;
                  var s1n = parseInt(sc.s1), s2n = parseInt(sc.s2);
                  if (isNaN(s1n) || isNaN(s2n)) return;
                  c.t1.forEach(function(p) {
                    if (!sessionStats[p.id]) return;
                    sessionStats[p.id].played++;
                    sessionStats[p.id].pointsFor += s1n;
                    sessionStats[p.id].pointsAgainst += s2n;
                    if (s1n > s2n) sessionStats[p.id].wins++;
                  });
                  c.t2.forEach(function(p) {
                    if (!sessionStats[p.id]) return;
                    sessionStats[p.id].played++;
                    sessionStats[p.id].pointsFor += s2n;
                    sessionStats[p.id].pointsAgainst += s1n;
                    if (s2n > s1n) sessionStats[p.id].wins++;
                  });
                });
              });
              onUpdateRanking(sessionStats);
            }, color: C.gl, style: { padding: "10px 24px", fontSize: 11 } }, "\ud83d\udcca Actualizar Ranking General"),
            session.rankingUpdated && h(Tag, { text: "\u2713 Ranking actualizado", color: C.gn })
          )
        ),
        // Match Analysis - shown when session has enough data
        h(MatchAnalysis, { allRounds: allRounds, scores: scores, players: sp, allPlayers: allPlayers })
      );
    })()
  );
}

// ============================================================
// MATCH ANALYSIS COMPONENT
// Generates a narrative commentary at the end of a completed session
// ============================================================
function MatchAnalysis(props) {
  var allRounds = props.allRounds || [];
  var scores = props.scores || {};
  var sp = props.players || [];
  var allPlayers = props.allPlayers || sp;
  if (!allRounds.length || !sp.length) return null;

  // Count filled games
  var totalGames = 0, filled = 0;
  allRounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      totalGames++;
      var sk = r.round + "-" + c.court;
      var sc = scores[sk];
      if (sc && sc.s1 !== "" && sc.s2 !== "" && !isNaN(parseInt(sc.s1)) && !isNaN(parseInt(sc.s2))) filled++;
    });
  });
  if (filled < totalGames * 0.8) return null; // Need 80%+ to analyze

  // Compute stats
  var stats = {};
  sp.forEach(function(p) { 
    var r = (p.stats && typeof p.stats.rating === "number") ? p.stats.rating : 0;
    stats[p.id] = { id: p.id, nickname: p.nickname, rating: r, wins: 0, losses: 0, draws: 0, played: 0, ptsFor: 0, ptsAg: 0, diff: 0, streak: [], partners: {}, opponents: {}, blowouts: 0, clutch: 0, p1Wins: 0, p1Played: 0, p2Wins: 0, p2Played: 0 }; 
  });

  allRounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      var sk = r.round + "-" + c.court;
      var sc = scores[sk];
      if (!sc || sc.s1 === "" || sc.s2 === "") return;
      var s1 = parseInt(sc.s1), s2 = parseInt(sc.s2);
      if (isNaN(s1) || isNaN(s2)) return;
      var t1Won = s1 > s2, t2Won = s2 > s1, draw = s1 === s2;
      var phase = r.phase || (r.round <= 5 ? 1 : 2);
      var close = Math.abs(s1 - s2) <= 1 && (s1 + s2) >= 3;
      var blowout = Math.abs(s1 - s2) >= 3;

      c.t1.forEach(function(p) {
        if (!stats[p.id]) return;
        var s = stats[p.id]; s.played++; s.ptsFor += s1; s.ptsAg += s2;
        if (t1Won) { s.wins++; s.streak.push("W"); } 
        else if (t2Won) { s.losses++; s.streak.push("L"); }
        else { s.draws++; s.streak.push("D"); }
        if (close && t1Won) s.clutch++;
        if (blowout && t1Won) s.blowouts++;
        if (phase === 1) { s.p1Played++; if (t1Won) s.p1Wins++; }
        else { s.p2Played++; if (t1Won) s.p2Wins++; }
        c.t1.forEach(function(pp) { if (pp.id !== p.id) s.partners[pp.id] = (s.partners[pp.id] || 0) + 1; });
        c.t2.forEach(function(pp) { s.opponents[pp.id] = (s.opponents[pp.id] || 0) + 1; });
      });
      c.t2.forEach(function(p) {
        if (!stats[p.id]) return;
        var s = stats[p.id]; s.played++; s.ptsFor += s2; s.ptsAg += s1;
        if (t2Won) { s.wins++; s.streak.push("W"); }
        else if (t1Won) { s.losses++; s.streak.push("L"); }
        else { s.draws++; s.streak.push("D"); }
        if (close && t2Won) s.clutch++;
        if (blowout && t2Won) s.blowouts++;
        if (phase === 1) { s.p1Played++; if (t2Won) s.p1Wins++; }
        else { s.p2Played++; if (t2Won) s.p2Wins++; }
        c.t2.forEach(function(pp) { if (pp.id !== p.id) s.partners[pp.id] = (s.partners[pp.id] || 0) + 1; });
        c.t1.forEach(function(pp) { s.opponents[pp.id] = (s.opponents[pp.id] || 0) + 1; });
      });
    });
  });

  Object.values(stats).forEach(function(s) { s.diff = s.ptsFor - s.ptsAg; s.winPct = s.played > 0 ? Math.round(s.wins / s.played * 100) : 0; });

  var ranked = Object.values(stats).sort(function(a, b) { 
    return b.wins !== a.wins ? b.wins - a.wins : b.diff !== a.diff ? b.diff - a.diff : b.rating - a.rating; 
  });

  // --- GENERATE INSIGHTS ---
  var insights = [];

  // 1. MVP
  if (ranked[0] && ranked[0].wins > 0) {
    var mvp = ranked[0];
    var mvpPct = mvp.winPct;
    insights.push({ icon: "\ud83c\udfc6", title: "MVP de la Jornada", text: mvp.nickname + " domina con " + mvp.wins + " victorias" + (mvpPct >= 70 ? " y un aplastante " + mvpPct + "% de efectividad" : " en " + mvp.played + " juegos") + ". " + (mvp.diff > 5 ? "Diferencial de +" + mvp.diff + " puntos." : ""), color: C.gl });
  }

  // 2. Underdog / Surprise
  ranked.forEach(function(s) {
    if (s.rating < 30 && s.winPct >= 50 && s.played >= 3) {
      insights.push({ icon: "\ud83c\udf1f", title: "Sorpresa del Da", text: s.nickname + " (rating " + s.rating.toFixed(0) + ") sorprende con " + s.winPct + "% de victorias. !Est jugando muy por encima de su nivel!", color: C.gn });
    }
  });

  // 3. Biggest upset  low-rated pair beat high-rated pair
  var upsets = [];
  allRounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      var sk = r.round + "-" + c.court;
      var sc = scores[sk]; if (!sc || sc.s1 === "" || sc.s2 === "") return;
      var s1 = parseInt(sc.s1), s2 = parseInt(sc.s2);
      if (isNaN(s1) || isNaN(s2)) return;
      var r1 = 0, r2 = 0;
      c.t1.forEach(function(p) { r1 += (stats[p.id] ? stats[p.id].rating : 0); });
      c.t2.forEach(function(p) { r2 += (stats[p.id] ? stats[p.id].rating : 0); });
      var delta = Math.abs(r1 - r2);
      if (delta >= 15) {
        var favWon = (r1 > r2 && s1 > s2) || (r2 > r1 && s2 > s1);
        if (!favWon && (s1 !== s2)) {
          var winners = s1 > s2 ? c.t1 : c.t2;
          var losers = s1 > s2 ? c.t2 : c.t1;
          upsets.push({ round: r.round, court: c.court, winners: winners.map(function(p){return p.nickname;}), losers: losers.map(function(p){return p.nickname;}), delta: delta, score: s1 > s2 ? s1+"-"+s2 : s2+"-"+s1 });
        }
      }
    });
  });
  if (upsets.length > 0) {
    upsets.sort(function(a,b){ return b.delta - a.delta; });
    var u = upsets[0];
    insights.push({ icon: "\ud83d\udca5", title: "Upset de la Jornada", text: u.winners.join(" y ") + " derrotan " + u.score + " a los favoritos " + u.losers.join(" y ") + " (R" + u.round + "-P" + u.court + ", " + u.delta.toFixed(0) + " puntos de rating).", color: C.or });
  }

  // 4. Longest streak
  ranked.forEach(function(s) {
    var maxW = 0, cur = 0;
    s.streak.forEach(function(r) { if (r === "W") { cur++; if (cur > maxW) maxW = cur; } else cur = 0; });
    s.maxWinStreak = maxW;
    var maxL = 0; cur = 0;
    s.streak.forEach(function(r) { if (r === "L") { cur++; if (cur > maxL) maxL = cur; } else cur = 0; });
    s.maxLoseStreak = maxL;
  });
  var streaker = ranked.slice().sort(function(a,b){ return b.maxWinStreak - a.maxWinStreak; })[0];
  if (streaker && streaker.maxWinStreak >= 3) {
    insights.push({ icon: "\ud83d\udd25", title: "Racha Imparable", text: streaker.nickname + " encaden " + streaker.maxWinStreak + " victorias consecutivas. !Intratable!", color: "#ff6b35" });
  }

  // 5. Clutch player
  var clutchPlayer = ranked.slice().sort(function(a,b){ return b.clutch - a.clutch; })[0];
  if (clutchPlayer && clutchPlayer.clutch >= 2) {
    insights.push({ icon: "\ud83c\udfaf", title: "Jugador Clutch", text: clutchPlayer.nickname + " gan " + clutchPlayer.clutch + " partidos cerrados (diferencia 1). Nervios de acero en los momentos clave.", color: C.cy });
  }

  // 6. Phase comparison
  ranked.forEach(function(s) {
    if (s.p1Played >= 2 && s.p2Played >= 2) {
      var p1Pct = Math.round(s.p1Wins / s.p1Played * 100);
      var p2Pct = Math.round(s.p2Wins / s.p2Played * 100);
      if (p2Pct - p1Pct >= 40) {
        insights.push({ icon: "\ud83d\ude80", title: "Despert en Fase 2", text: s.nickname + " pas de " + p1Pct + "% en Fase 1 a " + p2Pct + "% en King of the Court. Se encendi cuando importaba.", color: "#a78bfa" });
      } else if (p1Pct - p2Pct >= 40) {
        insights.push({ icon: "\ud83d\udca8", title: "Se Apag en Fase 2", text: s.nickname + " baj de " + p1Pct + "% en Fase 1 a " + p2Pct + "% en Fase 2. Cansancio o rival ms duro?", color: C.si });
      }
    }
  });

  // 7. Most draws
  var totalDraws = 0;
  Object.values(stats).forEach(function(s) { totalDraws += s.draws; });
  totalDraws = totalDraws / 2; // each draw counted twice
  if (totalDraws >= 3) {
    insights.push({ icon: "\ud83e\udd1d", title: "Jornada de Empates", text: totalDraws + " empates en la sesin. !Los equipos estuvieron muy parejos hoy!", color: C.tm });
  }

  // 8. Worst day
  var worst = ranked[ranked.length - 1];
  if (worst && worst.wins === 0 && worst.played >= 3) {
    insights.push({ icon: "\ud83d\ude22", title: "Da Difcil", text: worst.nickname + " no pudo sumar victorias en " + worst.played + " juegos. Maana ser otro da.", color: C.rd });
  }

  // 9. Best partnership
  var bestPair = null, bestPairWins = 0;
  allRounds.forEach(function(r) {
    r.courts.forEach(function(c) {
      var sk = r.round + "-" + c.court;
      var sc = scores[sk]; if (!sc || sc.s1 === "" || sc.s2 === "") return;
      var s1 = parseInt(sc.s1), s2 = parseInt(sc.s2);
      if (isNaN(s1) || isNaN(s2)) return;
      if (s1 > s2) { var pk = [c.t1[0].nickname, c.t1[1].nickname].sort().join(" y "); if (!bestPair || pk === bestPair) { bestPair = pk; bestPairWins++; } }
      if (s2 > s1) { var pk2 = [c.t2[0].nickname, c.t2[1].nickname].sort().join(" y "); if (!bestPair || pk2 === bestPair) { bestPair = pk2; bestPairWins++; } }
    });
  });

  // 10. Points machine
  var scorer = ranked.slice().sort(function(a,b){ return b.ptsFor - a.ptsFor; })[0];
  if (scorer && scorer.ptsFor >= ranked[0].ptsFor * 0.9) {
    insights.push({ icon: "\ud83d\udcaa", title: "Mquina de Puntos", text: scorer.nickname + " anot " + scorer.ptsFor + " puntos a favor" + (scorer.diff > 0 ? " con diferencial de +" + scorer.diff : "") + ". Ofensiva pura.", color: C.gn });
  }

  if (insights.length === 0) return null;

  // Limit to 6 best insights
  insights = insights.slice(0, 6);

  return h(Box, { style: { marginTop: 12, padding: 16 }, accent: "#a78bfa", glow: true },
    h(Label, { icon: "\ud83d\udcdd", text: "Anlisis de la Jornada", color: "#a78bfa" }),
    h("div", { style: { display: "grid", gap: 10 } },
      insights.map(function(ins, i) {
        return h("div", { key: i, style: { display: "flex", gap: 12, padding: "12px 14px", background: C.s1, borderRadius: 10, border: "1px solid " + ins.color + "20", borderLeft: "3px solid " + ins.color } },
          h("span", { style: { fontSize: 22, flexShrink: 0, lineHeight: 1.2 } }, ins.icon),
          h("div", { style: { flex: 1, minWidth: 0 } },
            h("div", { style: { fontSize: 12, fontWeight: 700, color: ins.color, fontFamily: F.d, marginBottom: 3 } }, ins.title),
            h("div", { style: { fontSize: 12, color: C.tx, lineHeight: 1.5, fontFamily: F.b } }, ins.text)
          )
        );
      })
    ),
    // Mini leaderboard
    h("div", { style: { marginTop: 14, padding: "10px 12px", background: C.s1, borderRadius: 10, border: "1px solid " + C.bd } },
      h("div", { style: { fontSize: 10, fontFamily: F.m, color: C.td, textTransform: "uppercase", letterSpacing: 1.5, marginBottom: 8 } }, "Resumen Estadstico"),
      h("div", { style: { display: "grid", gap: 4 } },
        ranked.slice(0, 6).map(function(s, i) {
          var barW = s.played > 0 ? Math.round(s.wins / s.played * 100) : 0;
          var streakStr = "";
          var cur = 0, best = ""; 
          for (var si = s.streak.length - 1; si >= Math.max(0, s.streak.length - 4); si--) {
            streakStr = (s.streak[si] === "W" ? "\ud83d\udfe2" : s.streak[si] === "L" ? "\ud83d\udd34" : "\ud83d\udfe1") + streakStr;
          }
          return h("div", { key: s.id, style: { display: "flex", alignItems: "center", gap: 8, padding: "4px 0" } },
            h("span", { style: { fontSize: 10, fontWeight: 800, color: i < 3 ? C.gl : C.td, fontFamily: F.m, width: 18, textAlign: "center" } }, i + 1),
            h(Avatar, { nickname: s.nickname, size: 22 }),
            h("div", { style: { flex: 1, minWidth: 0 } },
              h("div", { style: { display: "flex", alignItems: "center", gap: 6 } },
                h("span", { style: { fontSize: 12, fontWeight: 700, color: C.tx, fontFamily: F.d } }, s.nickname),
                h("span", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, s.wins + "W/" + s.losses + "L"),
                h("span", { style: { fontSize: 10, fontFamily: F.m } }, streakStr)
              ),
              h("div", { style: { display: "flex", alignItems: "center", gap: 6, marginTop: 2 } },
                h("div", { style: { flex: 1, height: 4, background: C.s3, borderRadius: 2, maxWidth: 100, overflow: "hidden" } },
                  h("div", { style: { height: "100%", width: barW + "%", background: barW >= 60 ? C.gn : barW >= 40 ? C.cy : C.or, borderRadius: 2 } })
                ),
                h("span", { style: { fontSize: 10, color: barW >= 60 ? C.gn : barW >= 40 ? C.cy : C.or, fontFamily: F.m, fontWeight: 700 } }, barW + "%"),
                s.diff !== 0 && h("span", { style: { fontSize: 10, color: s.diff > 0 ? C.gn : C.rd, fontFamily: F.m } }, (s.diff > 0 ? "+" : "") + s.diff)
              )
            )
          );
        })
      )
    )
  );
}

// ============================================================
// MAIN APP
// ============================================================
function App() {
  var playersState = React.useState([]);
  var players = playersState[0], setPlayers = playersState[1];
  var tabState = React.useState("create");
  var tab = tabState[0], setTab = tabState[1];
  var sessionsState = React.useState([]);
  var sessions = sessionsState[0], setSessions = sessionsState[1];
  var asState = React.useState(null);
  var activeSession = asState[0], setActiveSession = asState[1];
  var loadedState = React.useState(false);
  var sbLoaded = loadedState[0], setSbLoaded = loadedState[1];
  var rtState = React.useState("disconnected");
  var realtimeStatus = rtState[0], setRealtimeStatus = rtState[1];
  // Track device ID to avoid processing own changes
  var deviceIdRef = React.useRef("dev_" + Date.now() + "_" + Math.random().toString(36).substr(2, 6));

  // Load from Supabase on mount + subscribe to Realtime
  React.useEffect(function() {
    (async function() {
      try {
        var dbPlayers = await SB.loadPlayers();
        if (dbPlayers && dbPlayers.length > 0) {
          dbPlayers.forEach(function(p) { if (p.avatarUrl && p.avatarUrl.length > 100) AVATARS[p.nickname] = p.avatarUrl; });
          setPlayers(dbPlayers);
        }
        var dbSessions = await SB.loadSessions();
        if (dbSessions && dbSessions.length > 0) {
          setSessions(dbSessions);
          // Auto-migrate: if any session has players recovered from fallback,
          // save them back to result_json so future loads are clean
          dbSessions.forEach(function(s) {
            if (s.players && s.players.length > 0 && s.result && !s.result.players) {
              console.log("Auto-migrating players for session " + s.id);
              var fixedResult = Object.assign({}, s.result, { players: s.players });
              SB.updateSessionResult(s.id, fixedResult, {}, s.players);
            }
          });
        }
      } catch(e) { console.error("SB init error:", e); }
      setSbLoaded(true);

      // Subscribe to Realtime changes
      SB.onStatusChange(function(status) { setRealtimeStatus(status); });
      SB.subscribeRealtime(
        // On session change (scores, phase2, ranking updates)
        function(payload) {
          if (!payload.new) return;
          var row = payload.new;
          // Reload full session from Supabase to get complete data
          (async function() {
            var freshSessions = await SB.loadSessions();
            if (freshSessions && freshSessions.length > 0) {
              setSessions(freshSessions);
              // If the active session was updated, refresh it too
              setActiveSession(function(prev) {
                if (!prev || prev.id !== row.id) return prev;
                var found = freshSessions.find(function(s) { return s.id === row.id; });
                return found || prev;
              });
            }
          })();
        },
        // On player change (ranking, stats, active toggle)
        function(payload) {
          if (!payload.new) return;
          // Reload all players to stay in sync
          (async function() {
            var freshPlayers = await SB.loadPlayers();
            if (freshPlayers && freshPlayers.length > 0) {
              freshPlayers.forEach(function(p) { if (p.avatarUrl && p.avatarUrl.length > 100) AVATARS[p.nickname] = p.avatarUrl; });
              setPlayers(freshPlayers);
            }
          })();
        }
      );
    })();
    // Cleanup on unmount
    return function() { SB.unsubscribeRealtime(); };
  }, []);

  var toggle = React.useCallback(function(id) {
    setPlayers(function(p) {
      var updated = p.map(function(x) { return x.id === id ? Object.assign({}, x, { active: !x.active }) : x; });
      SB.savePlayers(updated);
      return updated;
    });
  }, []);
  var rank = React.useCallback(function(id, dir) {
    setPlayers(function(prev) {
      var s = prev.slice().sort(function(a, b) { return a.ranking - b.ranking; });
      var i = s.findIndex(function(p) { return p.id === id; });
      var j = i + dir;
      if (j < 0 || j >= s.length) return prev;
      var r1 = s[i].ranking, r2 = s[j].ranking;
      var updated = prev.map(function(p) { return p.id === s[i].id ? Object.assign({}, p, { ranking: r2 }) : p.id === s[j].id ? Object.assign({}, p, { ranking: r1 }) : p; });
      SB.savePlayers(updated);
      return updated;
    });
  }, []);

  var addPlayer = React.useCallback(function(nickname, phone, avatarUrl) {
    var maxRank = players.reduce(function(m, p) { return Math.max(m, p.ranking || 0); }, 0);
    var newPlayer = { id: Date.now(), name: nickname, nickname: nickname, phone: phone || "", ranking: maxRank + 1, active: true, avatarUrl: avatarUrl || null, stats: { played: 0, wins: 0, winRate: 0, diff: 0, rating: 0 } };
    if (avatarUrl) AVATARS[nickname] = avatarUrl;
    setPlayers(function(prev) {
      var updated = prev.concat([newPlayer]);
      SB.savePlayers(updated);
      return updated;
    });
  }, [players]);

  var deletePlayer = React.useCallback(function(id) {
    setPlayers(function(prev) {
      var updated = prev.filter(function(p) { return p.id !== id; });
      // Re-rank
      var sorted = updated.slice().sort(function(a, b) { return a.ranking - b.ranking; });
      sorted.forEach(function(p, i) { p.ranking = i + 1; });
      SB.savePlayers(updated);
      // Also delete from Supabase
      supabase.from("padel_players").delete().eq("id", id).then(function(res) {
        if (res.error) console.error("SB deletePlayer:", res.error);
      });
      return updated;
    });
  }, []);

  var handleCreate = function(session) {
    var id = Date.now();
    // Ensure players are persisted inside result for Supabase
    var resultWithPlayers = Object.assign({}, session.result, { players: session.players });
    var ns = Object.assign({}, session, { scores: {}, id: id, result: resultWithPlayers });
    setSessions(function(prev) { return [ns].concat(prev); });
    setActiveSession(ns);
    setTab("session");
    SB.saveSession(ns);
  };
  var handleUpdateScores = function(key, scoreObj) {
    if (!activeSession) return;
    var sid = activeSession.id;
    var newScores = Object.assign({}, activeSession.scores);
    newScores[key] = scoreObj;
    var updated = Object.assign({}, activeSession, { scores: newScores });
    setActiveSession(updated);
    setSessions(function(ss) { return ss.map(function(s) { return s.id === sid ? updated : s; }); });
    SB.updateScores(sid, newScores);
  };

  var handleEditSession = function(newPlayers) {
    if (!activeSession) return;
    var sid = activeSession.id;
    var newResult = computeSession(activeSession.totalTime, newPlayers, activeSession.numCourts);
    if (newResult.error) { alert("Error: " + newResult.error); return; }
    newResult.players = newPlayers; // persist players inside result
    var updated = Object.assign({}, activeSession, { players: newPlayers, result: newResult });
    setActiveSession(updated);
    setSessions(function(ss) { return ss.map(function(s) { return s.id === sid ? updated : s; }); });
    SB.saveSession(updated);
  };

  var handleGeneratePhase2 = function(dayRanking) {
    if (!activeSession) return;
    var sid = activeSession.id;
    var result = activeSession.result;
    var cfg = result.cfg;
    var p1Counts = result.p1Matches.counts;
    var p1RoundCount = result.p1Rounds;
    var p2Matches = buildPhase2Matches(cfg, activeSession.players, activeSession.numCourts, dayRanking, p1Counts, p1RoundCount);
    var newResult = Object.assign({}, result, { p2Matches: p2Matches, phase2Generated: true, players: activeSession.players });
    var updated = Object.assign({}, activeSession, { result: newResult });
    setActiveSession(updated);
    setSessions(function(ss) { return ss.map(function(s) { return s.id === sid ? updated : s; }); });
    SB.updateSessionResult(sid, newResult, { phase2_generated: true }, activeSession.players);
  };

  var handleDeleteRound = function(roundNum) {
    if (!activeSession) return;
    var sid = activeSession.id;
    var result = activeSession.result;
    var p1Rounds = result.p1Matches.rounds;
    var p2Rounds = result.p2Matches ? result.p2Matches.rounds : [];
    var isP1 = p1Rounds.some(function(r) { return r.round === roundNum; });
    var isP2 = p2Rounds.some(function(r) { return r.round === roundNum; });
    if (!isP1 && !isP2) return;
    // Remove round from appropriate phase
    var newP1 = isP1 ? p1Rounds.filter(function(r) { return r.round !== roundNum; }) : p1Rounds;
    var newP2 = isP2 ? p2Rounds.filter(function(r) { return r.round !== roundNum; }) : p2Rounds;
    // Renumber rounds sequentially
    var roundCounter = 1;
    newP1 = newP1.map(function(r) { return Object.assign({}, r, { round: roundCounter++ }); });
    newP2 = newP2.map(function(r) { return Object.assign({}, r, { round: roundCounter++ }); });
    var totalRounds = newP1.length + newP2.length;
    // Update config
    var newCfg = Object.assign({}, result.cfg, { rounds: totalRounds });
    var newP1Matches = Object.assign({}, result.p1Matches, { rounds: newP1 });
    var newP2Matches = result.p2Matches ? Object.assign({}, result.p2Matches, { rounds: newP2 }) : null;
    var newResult = Object.assign({}, result, { cfg: newCfg, p1Matches: newP1Matches, p1Rounds: newP1.length, p2Rounds: newP2.length, players: activeSession.players });
    if (newP2Matches) newResult.p2Matches = newP2Matches;
    // Clean up scores for deleted round and renumber existing
    var newScores = {};
    var oldScores = activeSession.scores || {};
    // Build old-to-new round mapping
    var allOldRounds = p1Rounds.concat(p2Rounds).filter(function(r) { return r.round !== roundNum; });
    var roundMap = {};
    var rc = 1;
    allOldRounds.forEach(function(r) { roundMap[r.round] = rc++; });
    Object.keys(oldScores).forEach(function(key) {
      var parts = key.split("-");
      var oldR = parseInt(parts[0]);
      if (oldR === roundNum) return; // skip deleted
      var newR = roundMap[oldR];
      if (newR) newScores[newR + "-" + parts[1]] = oldScores[key];
    });
    var updated = Object.assign({}, activeSession, { result: newResult, scores: newScores });
    setActiveSession(updated);
    setSessions(function(ss) { return ss.map(function(s) { return s.id === sid ? updated : s; }); });
    SB.saveSession(updated);
    SB.updateScores(sid, newScores);
  };

  var handleDeleteSession = function(sessionId) {
    setSessions(function(ss) { return ss.filter(function(s) { return s.id !== sessionId; }); });
    if (activeSession && activeSession.id === sessionId) {
      setActiveSession(null);
      setTab("history");
    }
    SB.deleteSession(sessionId);
  };

  // Update general ranking from completed tournament results
  var handleUpdateRanking = function(sessionResults) {
    // sessionResults: { playerId: { played, wins, pointsFor, pointsAgainst } }
    if (!activeSession) return;
    var sid = activeSession.id;
    setPlayers(function(prev) {
      return prev.map(function(p) {
        var sr = sessionResults[p.id];
        if (!sr || sr.played === 0) return p;
        var oldStats = p.stats || { played: 0, wins: 0, winRate: 0, diff: 0, rating: 0 };
        var newPlayed = oldStats.played + sr.played;
        var newWins = oldStats.wins + sr.wins;
        var newWinRate = newPlayed > 0 ? Math.round(newWins / newPlayed * 100) : 0;
        // diff = weighted average of old diff and session diff
        var sessionDiff = sr.played > 0 ? (sr.pointsFor - sr.pointsAgainst) / sr.played : 0;
        var newDiff = newPlayed > 0 ? ((oldStats.diff * oldStats.played) + (sessionDiff * sr.played)) / newPlayed : 0;
        newDiff = Math.round(newDiff * 100) / 100;
        var newRating = Math.round((newWinRate + newDiff * 10) * 100) / 100;
        return Object.assign({}, p, { stats: { played: newPlayed, wins: newWins, winRate: newWinRate, diff: newDiff, rating: newRating } });
      });
    });
    // Re-assign rankings based on new ratings
    setPlayers(function(prev) {
      var sorted = prev.slice().sort(function(a, b) { return (b.stats.rating || 0) - (a.stats.rating || 0); });
      var rankMap = {};
      sorted.forEach(function(p, i) { rankMap[p.id] = i + 1; });
      return prev.map(function(p) { return Object.assign({}, p, { ranking: rankMap[p.id] }); });
    });
    // Mark session as ranking updated
    var updated = Object.assign({}, activeSession, { rankingUpdated: true });
    setActiveSession(updated);
    setSessions(function(ss) { return ss.map(function(s) { return s.id === sid ? updated : s; }); });
    // Persist to Supabase
    SB.updateSessionResult(sid, activeSession.result, { ranking_updated: true }, activeSession.players);
    // Save updated players after a short delay to ensure state has settled
    setTimeout(function() {
      // Read current players from DOM-less approach: use the calculated values
      var finalPlayers = players.map(function(p) {
        var sr = sessionResults[p.id];
        if (!sr || sr.played === 0) return p;
        var oldStats = p.stats || { played: 0, wins: 0, winRate: 0, diff: 0, rating: 0 };
        var newPlayed = oldStats.played + sr.played;
        var newWins = oldStats.wins + sr.wins;
        var newWinRate = newPlayed > 0 ? Math.round(newWins / newPlayed * 100) : 0;
        var sessionDiff = sr.played > 0 ? (sr.pointsFor - sr.pointsAgainst) / sr.played : 0;
        var newDiff = newPlayed > 0 ? ((oldStats.diff * oldStats.played) + (sessionDiff * sr.played)) / newPlayed : 0;
        newDiff = Math.round(newDiff * 100) / 100;
        var newRating = Math.round((newWinRate + newDiff * 10) * 100) / 100;
        return Object.assign({}, p, { stats: { played: newPlayed, wins: newWins, winRate: newWinRate, diff: newDiff, rating: newRating } });
      });
      // Re-rank
      var sorted = finalPlayers.slice().sort(function(a, b) { return (b.stats.rating || 0) - (a.stats.rating || 0); });
      var rankMap = {};
      sorted.forEach(function(p, i) { rankMap[p.id] = i + 1; });
      finalPlayers = finalPlayers.map(function(p) { return Object.assign({}, p, { ranking: rankMap[p.id] }); });
      SB.savePlayers(finalPlayers);
    }, 500);
  };

  var navTabs = [
    { id: "create", icon: "\ud83c\udfae", label: "Crear Partida" },
    { id: "history", icon: "\ud83d\udccb", label: "Historial" + (sessions.length ? " (" + sessions.length + ")" : "") },
    { id: "roster", icon: "\ud83d\udc65", label: "Jugadores" },
  ];
  var confirmDelSessState = React.useState(null);
  var confirmDelSess = confirmDelSessState[0], setConfirmDelSess = confirmDelSessState[1];

  return h("div", { style: { minHeight: "100vh", background: "radial-gradient(ellipse at 30% -10%, #0d1a3a 0%, " + C.bg + " 70%)", color: C.tx, fontFamily: F.b, padding: 16 } },
    h("div", { style: { maxWidth: 900, margin: "0 auto" } },
      // Header
      h("div", { style: { textAlign: "center", paddingTop: 12, marginBottom: 24 } },
        h("div", { style: { display: "flex", justifyContent: "center", marginBottom: 8 } },
          h(RealtimeIndicator, { status: realtimeStatus })
        ),
        h("div", { style: { fontSize: 9, color: C.cy, fontFamily: F.m, letterSpacing: 3, textTransform: "uppercase", marginBottom: 5 } }, "Padel Tournament Engine v3.8"),
        h("h1", { style: { fontSize: "clamp(24px, 5vw, 38px)", fontWeight: 800, fontFamily: F.d, background: "linear-gradient(135deg, " + C.wh + ", " + C.cy + ")", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", lineHeight: 1.1, marginBottom: 3 } }, "King of the Court"),
        h("p", { style: { fontSize: 11, color: C.td } }, players.length + " jugadores registrados")
      ),
      tab === "session" && activeSession ?
        h(SessionDetail, { session: activeSession, onBack: function() { setActiveSession(null); setTab("history"); }, onUpdateScores: handleUpdateScores, onEditSession: handleEditSession, onGeneratePhase2: handleGeneratePhase2, onUpdateRanking: handleUpdateRanking, onDeleteRound: handleDeleteRound, allPlayers: players.concat((activeSession.players || []).filter(function(p) { return p.isGuest; })) })
      : h("div", null,
          h(TabBar, { tabs: navTabs, active: tab, onChange: function(t) { setActiveSession(null); setTab(t); } }),
          tab === "create" && h(CreateSession, { players: players, onCreateSession: handleCreate }),
          tab === "history" && h("div", null,
            h(Label, { icon: "\ud83d\udccb", text: "Partidas Creadas" }),
            sessions.length === 0 ? h(Box, { style: { textAlign: "center", padding: 36 } }, h("span", { style: { fontSize: 36 } }, "\ud83c\udfae"), h("div", { style: { color: C.td, fontSize: 12, marginTop: 8 } }, "Aun no has creado partidas"))
            : h("div", { style: { display: "grid", gap: 8 } },
                sessions.map(function(s, i) {
                  // Calculate session completion status
                  var sScores = s.scores || {};
                  var sP1 = s.result.p1Matches || { rounds: [] };
                  var sP2 = s.result.p2Matches || null;
                  var sPhase2Gen = s.result.phase2Generated || false;
                  var sAllRounds = sP1.rounds.slice();
                  if (sPhase2Gen && sP2) sAllRounds = sAllRounds.concat(sP2.rounds);
                  var sTotalGames = sAllRounds.reduce(function(acc, r) { return acc + r.courts.length; }, 0);
                  var sFilled = Object.keys(sScores).filter(function(k) { var sc = sScores[k]; return sc && sc.s1 !== "" && sc.s2 !== ""; }).length;
                  var sIsComplete = sPhase2Gen && sFilled === sTotalGames && sTotalGames > 0;
                  // Calculate winner
                  var sWins = {};
                  s.players.forEach(function(p) { sWins[p.id] = 0; });
                  if (sFilled > 0) {
                    sAllRounds.forEach(function(r) {
                      r.courts.forEach(function(c) {
                        var sk = r.round + "-" + c.court;
                        var sc = sScores[sk];
                        if (!sc || sc.s1 === "" || sc.s2 === "") return;
                        var s1n = parseInt(sc.s1), s2n = parseInt(sc.s2);
                        if (isNaN(s1n) || isNaN(s2n)) return;
                        if (s1n > s2n) c.t1.forEach(function(p) { if (sWins[p.id] !== undefined) sWins[p.id]++; });
                        if (s2n > s1n) c.t2.forEach(function(p) { if (sWins[p.id] !== undefined) sWins[p.id]++; });
                      });
                    });
                  }
                  var sWinner = null;
                  if (sIsComplete) {
                    var maxW = 0;
                    s.players.forEach(function(p) { if ((sWins[p.id] || 0) > maxW) { maxW = sWins[p.id]; sWinner = p; } });
                  }
                  // P1 completion
                  var sP1Total = sP1.rounds.reduce(function(acc, r) { return acc + r.courts.length; }, 0);
                  var sP1Filled = 0;
                  sP1.rounds.forEach(function(r) { r.courts.forEach(function(c) { var sk = r.round + "-" + c.court; var sc = sScores[sk]; if (sc && sc.s1 !== "" && sc.s2 !== "" && !isNaN(parseInt(sc.s1)) && !isNaN(parseInt(sc.s2))) sP1Filled++; }); });
                  var sP1Complete = sP1Total > 0 && sP1Filled === sP1Total;

                  return h(Box, { key: i, onClick: function() { setActiveSession(sessions[i]); setTab("session"); }, style: { cursor: "pointer", padding: 14 }, accent: sIsComplete ? C.gl : C.cy },
                    h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" } },
                      h("div", null,
                        h("div", { style: { fontSize: 14, fontWeight: 700, color: C.tx, fontFamily: F.d } }, "\ud83d\udcc5 " + s.date + " \u00b7 " + s.time),
                        h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m, marginTop: 2 } }, s.players.length + " jugadores \u00b7 " + s.numCourts + " pistas \u00b7 " + s.totalTime + " min")
                      ),
                      h("div", { style: { textAlign: "right" } },
                        sIsComplete && sWinner ? h("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: 2 } },
                          h("div", { style: { position: "relative", display: "inline-block" } },
                            h(Avatar, { nickname: sWinner.nickname, size: 38 }),
                            h("div", { style: { position: "absolute", top: -10, left: "50%", transform: "translateX(-50%)", fontSize: 16, lineHeight: "1", filter: "drop-shadow(0 1px 2px rgba(0,0,0,.5))" } }, "\ud83d\udc51")
                          ),
                          h("div", { style: { fontSize: 11, fontWeight: 800, color: C.gl, fontFamily: F.d, textAlign: "center", marginTop: 1 } }, sWinner.nickname)
                        ) : h("div", null,
                          h("div", { style: { fontSize: 18, fontWeight: 800, color: C.cy, fontFamily: F.d } }, s.result.cfg.rounds),
                          h("div", { style: { fontSize: 10, color: C.td, fontFamily: F.m } }, "rondas")
                        )
                      )
                    ),
                    h("div", { style: { display: "flex", gap: 4, marginTop: 8, flexWrap: "wrap", alignItems: "center" } },
                      // Status tags
                      sIsComplete ? h(Tag, { text: "\u2713 Completo", color: C.gn, sm: true })
                        : sFilled > 0 ? h(Tag, { text: sFilled + "/" + sTotalGames + " jugados", color: C.or, sm: true })
                        : h(Tag, { text: "Sin iniciar", color: C.td, sm: true }),
                      // Phase status
                      h(Tag, { text: "F1: " + (sP1Complete ? "\u2713" : sP1Filled + "/" + sP1Total), color: sP1Complete ? C.gn : C.cy, sm: true }),
                      sPhase2Gen ? h(Tag, { text: "F2: " + (sIsComplete ? "\u2713" : "en curso"), color: sIsComplete ? C.gn : C.gl, sm: true })
                        : h(Tag, { text: "F2: " + (sP1Complete ? "lista" : "\ud83d\udd12"), color: sP1Complete ? C.gl : C.td, sm: true }),
                      h(Tag, { text: fmtDurationSec(s.result.cfg.durationSec || s.result.cfg.duration * 60) + "/juego", color: C.tm, sm: true }),
                      s.result.cfg.remainder === 0 && h(Tag, { text: "\u2713 Equidad", color: C.gn, sm: true }),
                      s.rankingUpdated && h(Tag, { text: "\ud83d\udcca Ranking", color: C.gl, sm: true })
                    ),
                    // Top 3 winners if complete
                    sIsComplete && h("div", { style: { display: "flex", gap: 6, marginTop: 8, padding: "6px 8px", background: C.gl + "08", borderRadius: 7, border: "1px solid " + C.gl + "15" } },
                      s.players.slice().sort(function(a, b) { return (sWins[b.id] || 0) - (sWins[a.id] || 0); }).slice(0, 3).map(function(p, idx) {
                        var medals = ["\ud83e\udd47", "\ud83e\udd48", "\ud83e\udd49"];
                        return h("div", { key: p.id, style: { display: "flex", alignItems: "center", gap: 3 } },
                          h("span", { style: { fontSize: 12 } }, medals[idx]),
                          h(Avatar, { nickname: p.nickname, size: 18 }),
                          h("span", { style: { fontSize: 10, fontWeight: 700, color: C.tx, fontFamily: F.d } }, p.nickname),
                          h("span", { style: { fontSize: 9, fontWeight: 800, color: C.gn, fontFamily: F.m } }, (sWins[p.id] || 0) + "W")
                        );
                      })
                    ),
                    // Avatars if not complete
                    !sIsComplete && h("div", { style: { display: "flex", gap: 2, marginTop: 8 } },
                      s.players.slice(0, 12).map(function(p) { return h(Avatar, { key: p.id, nickname: p.nickname, size: 22 }); }),
                      s.players.length > 12 && h("div", { style: { width: 22, height: 22, borderRadius: "50%", background: C.s3, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 10, color: C.tm, fontFamily: F.m } }, "+" + (s.players.length - 12))
                    ),
                    // Delete session
                    confirmDelSess === s.id ? h("div", { onClick: function(e) { e.stopPropagation(); }, style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginTop: 8, padding: "8px 10px", background: C.rd + "0a", borderRadius: 7, border: "1px solid " + C.rd + "30" } },
                      h("span", { style: { fontSize: 11, color: C.rd, fontFamily: F.m, fontWeight: 600 } }, "\u26a0\ufe0f Eliminar esta partida?"),
                      h("div", { style: { display: "flex", gap: 6 } },
                        h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDelSess(null); handleDeleteSession(s.id); }, style: { padding: "5px 14px", border: "none", borderRadius: 6, background: C.rd, color: "#fff", cursor: "pointer", fontSize: 11, fontWeight: 700, fontFamily: F.m } }, "\u2713 Eliminar"),
                        h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDelSess(null); }, style: { padding: "5px 14px", border: "1px solid " + C.bd, borderRadius: 6, background: "transparent", color: C.tm, cursor: "pointer", fontSize: 11, fontFamily: F.m } }, "Cancelar")
                      )
                    ) : h("div", { style: { display: "flex", justifyContent: "flex-end", marginTop: 6 } },
                      h("button", { onClick: function(e) { e.stopPropagation(); setConfirmDelSess(s.id); }, style: { padding: "3px 8px", border: "none", borderRadius: 5, background: "transparent", color: C.rd, cursor: "pointer", fontSize: 10, fontFamily: F.m, opacity: 0.4, transition: "opacity .2s" }, onMouseEnter: function(e) { e.target.style.opacity = 1; }, onMouseLeave: function(e) { e.target.style.opacity = 0.4; } }, "\ud83d\uddd1\ufe0f Eliminar")
                    )
                  );
                })
              )
          ),
          tab === "roster" && h(Box, null, h(Roster, { players: players, onToggle: toggle, onRank: rank, onAdd: addPlayer, onDelete: deletePlayer }))
        ),
      h("div", { style: { textAlign: "center", padding: "20px 0 36px", fontSize: 9, color: C.td, fontFamily: F.m } }, "Padel Tournament Engine v3.8 \u00b7 Realtime Sync \u00b7 Player Persistence Fix")
    )
  );
}

ReactDOM.render(h(App), document.getElementById("root"));
</script>
</body>
</html>
